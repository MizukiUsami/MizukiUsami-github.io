<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用事件监听机制实现跨模块调用</title>
      <link href="/2023/07/22/%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/"/>
      <url>/2023/07/22/%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%B7%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="使用Spring事件监听机制实现跨模块调用"><a href="#使用Spring事件监听机制实现跨模块调用" class="headerlink" title="使用Spring事件监听机制实现跨模块调用"></a>使用Spring事件监听机制实现跨模块调用</h1><p>最近一个项目，有两个模块，A模块需要依赖B模块，但现在B模块有地方需要调用A模块的方法，如果直接依赖，又会产生循环依赖问题。最终选择使用spring的事件监听来解决该问题。</p><p>思路就是，B模块去发布事件，A中监听，得到数据后，通过引用返回给B。</p><p>首先是定义事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">getUserInfoEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> Integer griddingId;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder griddingName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">getUserInfoEvent</span><span class="params">(Object source, String message, Integer griddingId, StringBuilder griddingName)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">        <span class="built_in">this</span>.griddingId = griddingId;</span><br><span class="line">        <span class="built_in">this</span>.griddingName = griddingName;<span class="comment">//接收要获取到值的StringBuilder</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">getGriddingName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> griddingName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getGriddingId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> griddingId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后在B中去发布事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   ApplicationEventPublisher applicationEventPublisher;   <span class="comment">//这个必须注入</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> SysUserVO <span class="title function_">getUserInfo</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">       <span class="type">SysUser</span> <span class="variable">user</span> <span class="operator">=</span> getById(userId);</span><br><span class="line"></span><br><span class="line">       <span class="type">Integer</span> <span class="variable">griddingId</span> <span class="operator">=</span> user.getGriddingId();</span><br><span class="line">       StringBuilder griddingName= <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  <span class="comment">//使用stringbuilder进行引用字符串操作，来获取需要的值</span></span><br><span class="line"><span class="comment">//上面是业务相关</span></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       <span class="type">getUserInfoEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">getUserInfoEvent</span>(<span class="built_in">this</span>,<span class="string">&quot;发布“获取用户信息”事件&quot;</span>,griddingId,griddingName); <span class="comment">//定义事件</span></span><br><span class="line">       applicationEventPublisher.publishEvent(event);  <span class="comment">//发布事件</span></span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//下面是获取到数据之后的操作，不重要</span></span><br><span class="line">       <span class="comment">//这里事件是同步进行的</span></span><br><span class="line"></span><br><span class="line">       <span class="type">SysUserVO</span> <span class="variable">sysUserVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SysUserVO</span>();</span><br><span class="line">       BeanUtils.copyProperties(user,sysUserVO);</span><br><span class="line"></span><br><span class="line">       sysUserVO.setGriddingName(griddingName.toString());</span><br><span class="line"></span><br><span class="line">       <span class="comment">//  找到该用户所属角色</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">roleName</span> <span class="operator">=</span> getRoleByUserId(userId);</span><br><span class="line">       sysUserVO.setRoleName(roleName);</span><br><span class="line"></span><br><span class="line">       <span class="type">SysUser</span> <span class="variable">parentUser</span> <span class="operator">=</span> sysUserMapper.selectById(user.getParentId());</span><br><span class="line">       sysUserVO.setParentName(ObjectUtils.isEmpty(parentUser) ? <span class="literal">null</span> : parentUser.getUserName());</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> sysUserVO;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>最后在A中监听事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getGriddingNameByUserIdEventListener</span><span class="params">(getUserInfoEvent event)</span> &#123; <span class="comment">//参数必须填写要监听的事件类，事件发布后这边就会监听到</span></span><br><span class="line">    <span class="comment">//形参event中存有传递的相关数据</span></span><br><span class="line">    System.out.println(event.getMessage()); <span class="comment">//会打印出---发布“获取用户信息”事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面为个人业务相关代码</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">griddingId</span> <span class="operator">=</span> event.getGriddingId();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">griddingName</span> <span class="operator">=</span> event.getGriddingName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再通过网格id来查找对应的网格信息</span></span><br><span class="line">    <span class="type">GriddingArea</span> <span class="variable">griddingArea</span> <span class="operator">=</span> getOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;GriddingArea&gt;().eq(GriddingArea::getId, griddingId));</span><br><span class="line"></span><br><span class="line">    griddingName.append(griddingArea.getGriddingName());  <span class="comment">//使用同一个StringBuilder对象来操作，这里把获取到的字符串存入后，事件发布者那边就能得到数据了。</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;griddingName&quot;</span>+griddingName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好用👍</p>]]></content>
      
      
      <categories>
          
          <category> java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring事件监听 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos</title>
      <link href="/2023/07/12/Nacos/"/>
      <url>/2023/07/12/Nacos/</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="作为注册中心："><a href="#作为注册中心：" class="headerlink" title="作为注册中心："></a>作为注册中心：</h2><p>Nacos 文档地址： <a href="https://nacos.io/zh-cn/docs/quick-start.html">https://nacos.io/zh-cn/docs/quick-start.html</a></p><p><strong>1.首先需要下载nacos中间件（nacos-server）并启动</strong></p><p><strong>2.引入注册中心依赖后，在配置文件中配置Nacos Server地址与微服务应用名（即可将微服务注册到Nacos）</strong></p><p>pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.properties(后续会直接把该配置放在nacos中):</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848  #nacos地址</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">service-provider #微服务名称</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8000 #微服务端口</span></span><br></pre></td></tr></table></figure><p><strong>3.在启动类上使用@EnableDiscoveryClient 开启服务注册发现功能</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.启动应用，观察 nacos 服务列表是否已经注册上服务</strong></p><h2 id="作为配置中心："><a href="#作为配置中心：" class="headerlink" title="作为配置中心："></a>作为配置中心：</h2><p><strong>1.引入配置中心依赖</strong></p><p>pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.在bootstrap中配置nacos config信息</strong></p><p>bootstrap.properties:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">nacos-config-example</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure><p><strong>3.在nacos中添加配置</strong></p><p>相关注解：</p><p>@RefreshScope：动态获取并刷新配置 </p><p>@Value(“${配置项的名}”)：获取配置的数据</p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/06/01/Redis/"/>
      <url>/2023/06/01/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p><img src="/2023/06/01/Redis/image-20230601142141501.png" alt="image-20230601142141501"></p><p>1.先删缓存再删数据库：可能发生线程1删除缓存后但是未更新数据库前，线程2去查询，导致从数据库中查询到旧数据，并且重新写入缓存。之后线程1才对数据库进行更新</p><p><img src="/2023/06/01/Redis/image-20230601142245684.png" alt="image-20230601142245684"></p><p>2.先删数据库再删缓存：可能发生线程1去查询缓存的时候查不到，从而去数据库中查询到旧数据，然后此时线程2对数据库进行更新并删除缓存后，线程1又把旧数据写入缓存。但是可能性较小，因为<strong>写入缓存的时间远小于更新数据库的时间</strong>，所以一般情况下都只会是线程1把旧数据写入缓存后，线程2才更新数据库并且删除缓存。</p><p><img src="/2023/06/01/Redis/image-20230601142501594.png" alt="image-20230601142501594"></p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指在查询缓存中不存在的数据，每次请求都会直接查询数据库或其他存储介质，从而造成请求过多、资源浪费等问题。这种情况常出现在恶意攻击或误操作等场景中。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li><p><strong>布隆过滤器：</strong>在查询缓存前，使用布隆过滤器预先判断请求的键是否存在，从而减轻数据库压力。</p><p>布隆过滤器（Bloom Filter）是一种常用的碰撞检测数据结构，可以用来判断一个元素是否在集合中。它由一个位数组和多个哈希函数组成，其中位数组中的每个元素都只能取 0 或 1 两个值。</p><p>在使用布隆过滤器前，需要预先设置位数组的长度和哈希函数的个数。当要加入一个新元素时，会先经过多个不同的哈希函数，将元素映射到位数组中的多个位置上，并将这些位置的值置为 1。而在查询元素是否在集合中时，同样会经过这些哈希函数，获取元素哈希值对应的多个位数组位置，只要有任何一个位置的值为 0，则说明该元素不在集合中，如果所有的位数组位置值都为 1，则说明该元素可能在集合中或有其他元素冲突，因此需要再进一步验证。</p><p>布隆过滤器的性能优点在于，它可以在常数时间内判断一个元素是否在集合中，即使元素数量很大，而且占用的空间也比较小。但是，<em>布隆过滤器也有缺点，即存在一定的误判率</em>，即已存在的元素可能被误认为不存在于集合中，这是因为哈希函数映射到位数组位置时可能会产生冲突。但是，误判率可以通过调整哈希函数个数和位数组长度来控制。</p><p><img src="/2023/06/01/Redis/image-20230601144021518.png" alt="image-20230601144021518"></p><p><img src="/2023/06/01/Redis/image-20230601143658516.png" alt="image-20230601143658516"></p></li><li><p><strong>缓存空对象：</strong>将请求的键值对应的值设置为空对象，在下一次请求时，可以直接从缓存中获取。</p><img src="/2023/06/01/Redis/image-20230601143519611.png" class="" title="image-20230601143519611"><p><img src="/2023/06/01/Redis/image-20230601143546037.png" alt="image-20230601143546037"></p></li></ol><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指因为缓存中的大量数据同时失效或被清空，导致大量的请求直接打到数据库造成宕机或响应时间变得极长的现象。缓存雪崩通常会发生在一个较长时间内，由于请求量大、压力集中，导致系统崩溃。</p><p><img src="/2023/06/01/Redis/image-20230601145554707.png" alt="image-20230601145554707"></p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>◆给不同的Key的TTL添加随机值（避免同时到期）<br>◆利用Redis集群提高服务的可用性（避免redis宕机）<br>◆给缓存业务添加降级限流策略（牺牲服务，保护数据库）<br>◆给业务添加多级缓存（除redis外设立其他缓存）</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿指的是一个存在缓存中但过期了的数据，在缓存失效的短时间内，有大量的请求同时涌入后端数据库或其他存储介质中进行查询，从而导致数据库或存储介质的访问压力过大，甚至可能引起服务崩溃的一种现象。为了避免缓存击穿，我们需要保证缓存的稳定性和可靠性，对于高访问频率或高并发的数据需要采用多重保障措施，避免频繁访问数据库，从而提高系统的稳定性和性能。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>1.互斥锁：性能较差</p><p><img src="/2023/06/01/Redis/image-20230601151712205.png" alt="image-20230601151712205"></p><p>2.逻辑过期：不设置ttl，在存入的数据中自行设置过期时间。发现过期了就拿锁并开启新线程去重建缓存数据，但是不会等待重建完成，而是直接先返回旧数据。</p><p><img src="/2023/06/01/Redis/image-20230601152147515.png" alt="image-20230601152147515"></p><p><strong>对比：</strong></p><table><thead><tr><th align="left">解决方案</th><th align="left">优点</th><th>缺点</th></tr></thead><tbody><tr><td align="left">互斥锁</td><td align="left">●没有额外的内存消耗<br/>●保证一致性<br/>●实现简单</td><td>●线程需要等待，性能受影响<br/>●可能有死锁风险</td></tr><tr><td align="left">逻辑过期</td><td align="left">●线程无需等待，性能较好</td><td>●不保证一致性<br/>●有额外内存消耗<br/>●实现复杂</td></tr></tbody></table><h3 id="和缓存穿透的区别"><a href="#和缓存穿透的区别" class="headerlink" title="和缓存穿透的区别"></a>和缓存穿透的区别</h3><ol><li><p>生命周期不同：缓存击穿指的是一个<em>存在缓存中但过期了</em>的数据，在缓存失效的短时间内，有大量的请求同时涌入后台数据库或其他存储介质中进行查询，从而导致数据库或存储介质的访问压力过大的一种现象。</p><p>而缓存穿透则是指查询一个<em>不存在的</em>数据，即缓存和数据库中都没有该数据，导致每次查询都要到数据库中查找，从而导致数据库查询压力过大。</p></li><li><p>发生原因不同：缓存击穿通常是由于一个热点数据失效或没有缓存而引起的，</p><p>而缓存穿透要么是因为缓存中的数据不足以支持所有的查询，要么是因为攻击者恶意查询一些不存在的数据，造成无效查询。</p></li><li><p>解决方法不同：解决缓存击穿的方法主要是设置热点数据永久缓存，使用分布式锁等技术防止多个线程同时访问后端数据库，或者使用备用缓存等手段。</p><p>解决缓存穿透的方法主要是设置缓存空对象，例如将不存在的数据的缓存设置成一个空对象，避免重复查询，同时使用布隆过滤器等技术防止恶意查询。</p></li></ol><h2 id="秒杀案例"><a href="#秒杀案例" class="headerlink" title="秒杀案例"></a>秒杀案例</h2><h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><p>参考： <a href="https://www.bilibili.com/video/BV1cr4y1671t?p=52&vd_source=d978901fca1f9c4ec4151a9d124fee2d">实战篇-05.优惠券秒杀-库存超卖问题分析_哔哩哔哩_bilibili</a></p><p><img src="/2023/06/01/Redis/image-20230602155346427.png" alt="image-20230602155346427"></p><p>上面判断是否大于0是通过一开始查询库存查出来的数据来判断的。</p><p>解决方法：使用CAS（compare and set）法，用库存量来代替乐观锁本身的版本号法，每次更新比较一下库存是否有变化，没变化才更新。但这种情况下会造成失败率过高，所以可以将条件从等于改为库存&gt;0就行（等于就是去减库存的时候再判断一下库存是不是大于0）</p><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>参考：<a href="https://www.bilibili.com/video/BV1cr4y1671t?p=54&vd_source=d978901fca1f9c4ec4151a9d124fee2d">实战篇-07.优惠券秒杀-实现一人一单功能_哔哩哔哩_bilibili</a></p><p>判断该用户是否已经参与过抢购，为避免并发问题需要使用悲观锁，以用户id为锁，利用<strong>intern</strong>（去常量池中找字符串值相同的对象，返回它的引用）保证用户id相同时，锁就相同</p><p><img src="/2023/06/01/Redis/image-20230602162804885.png" alt="image-20230602162804885"></p><p><img src="/2023/06/01/Redis/image-20230602162913714.png" alt="image-20230602162913714"></p><p>集群模式下上诉方法失效：<a href="https://www.bilibili.com/video/BV1cr4y1671t?p=55&vd_source=d978901fca1f9c4ec4151a9d124fee2d">实战篇-08.优惠券秒杀-集群下的线程并发安全问题_哔哩哔哩_bilibili</a> </p><p>集群下，每台服务jvm不同，只能控制自己服务下的锁</p><h2 id="分布式🔒"><a href="#分布式🔒" class="headerlink" title="分布式🔒"></a>分布式🔒</h2><p>分布式锁是一种用于解决分布式系统中并发访问共享资源的问题的机制。在分布式系统中，多个应用程序可能会同时访问同一个共享资源，例如数据库、分布式缓存或消息队列等，如果不采取措施限制对该资源的访问，可能会导致数据不一致或其他问题。</p><p>分布式锁主要解决以下两个问题：</p><ol><li><p>多个客户端并发访问某个共享资源时，需要保证只有一个客户端能够访问该资源，防止数据的异常、错乱或丢失。</p></li><li><p>如果分布式系统中的多个节点操作同一个共享资源，需要保证所有节点之间的操作顺序是一致的，防止出现竞争和死锁等问题。</p></li></ol><p>分布式锁有多种实现方式，比如使用数据库、分布式缓存和ZooKeeper等。其中，使用ZooKeeper实现分布式锁是较为常见的一种方法。</p><p><a href="https://www.bilibili.com/video/BV1cr4y1671t/?p=56&spm_id_from=pageDriver&vd_source=d978901fca1f9c4ec4151a9d124fee2d">实战篇-09.分布式锁-基本原理和不同实现方式对比_哔哩哔哩_bilibili</a></p><p><img src="/2023/06/01/Redis/image-20230603144131054.png" alt="image-20230603144131054"></p><p>简单来说就是不使用jvm内部本身的锁监视器，而是使用一个共享的锁监视器（多进程可见、互斥、高可用、高性能、安全性）</p><h3 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h3><p><img src="/2023/06/01/Redis/image-20230603145253010.png" alt="image-20230603145253010"></p><p>在Redis中实现分布式锁的机制很简单，可以通过Redis的SETNX命令实现。</p><p>具体实现步骤如下：</p><ol><li>应用程序请求获取锁时，以锁名作为Redis的key，当前时间戳作为value，使用SETNX命令尝试设置该key的值。</li><li>如果SETNX命令返回1，表示获取锁成功，应用程序继续执行临界区代码；如果返回0，则表示锁已被其他应用程序获取，应用程序需要等待并重试。</li><li>可以设置锁的超时时间来避免锁未及时释放导致死锁，应用程序在执行完临界区代码后需使用DEL命令释放锁，或在获取锁时设置锁的超时时间（通过设置过期时间）。</li><li>在并发情况下，可能会出现锁已被其他应用程序释放但获取锁的应用程序仍未获取到的情况，此时需要对应用程序加入等待机制，以便在锁释放后能够立即获取锁。</li></ol><p><img src="/2023/06/01/Redis/image-20230603171756614.png"></p><p>以下是Java语言实现的Redis分布式锁示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_SUCCESS</span> <span class="operator">=</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">RELEASE_SUCCESS</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLock</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间（毫秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryGetDistributedLock</span><span class="params">(String lockKey, String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试获取分布式锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">releaseDistributedLock</span><span class="params">(String lockKey, String requestId)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Lua脚本保证原子性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, <span class="number">1</span>, lockKey, requestId);</span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java实现中，我们使用了Jedis客户端和Redis的SET命令此外，使用了Redis的eval命令以Lua脚本的方式来保证解锁的原子性。</p><p>（Redis支持通过Lua脚本进行批量操作和一些特定的业务逻辑，其原因是Lua脚本是轻量级的脚本语言，能够很好地运行于Redis内核之中，且支持强大的操作和控制。由于Lua脚本不需要经过编译而能直接执行，因此使得Redis支持实时编写和即时执行一些灵活的业务逻辑成为可能。但是需要注意的是，在Redis中使用Lua脚本时，脚本执行过程中并不是所有Redis命令都可以使用，而是有一些特殊的规则和限制。）</p><h3 id="误删问题"><a href="#误删问题" class="headerlink" title="误删问题"></a>误删问题</h3><p>Redis分布式锁的一个问题是误删。如果一个获得锁的客户端把自己的 key 锁数据过期时间设置太短，比如 5 秒钟，但是由于某些原因需要超过 5 秒钟才能完成任务。如果这个任务在 5 秒钟内没有完成，那么锁就会自动过期被删除。如果此时另外一个客户端获得了同一个 key 的锁，那么这个时候就存在一个危险：原本应该由第一个客户端来执行的任务可能被第二个客户端在进行。</p><p>为了避免这种情况，常见的做法是在每个客户端获取锁时为锁设置一个唯一的 标识，并在释放锁时检查 标识 是否匹配，只有匹配的 标识 才能释放锁。这样即使另外一个客户端获取了同一个 key 的锁，也不能通过释放锁的方式来误删第一个客户端的锁。同时在对锁进行续期时也需要更新 标识，避免第一个客户端的已过期的 标识 可能被第二个客户端续期。</p><h3 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h3><p>Redis 中常用的分布式锁实现方式是在 Redis 中使用 setnx 命令来设置锁的 key，同时设置一个过期时间以避免锁一直存在。但是这种方式有可能存在原子性问题。</p><p>举个例子：A：假设客户端1创建了锁，但是在设置过期时间之前宕机了，那么锁的 key 就无法被删除，其他客户端会一直获取不到锁。</p><p>B:客户端1释放锁检查匹匹配之后宕机了，达到过期时间后自动删除key，客户端2又来取到了锁，结果客户端1又恢复正常了，它继续之前检查匹配之后的删除锁操作，就会删除客户端2的锁。</p><p>为了避免这种情况，可以将锁的创建和过期时间设置操作合并为一条命令（将锁的检查匹配与删除锁合并），常用的方式是使用 Redis 的 EVAL 命令，设置 Lua 脚本来保证锁操作的原子性：</p><p><img src="/2023/06/01/Redis/image-20230603170525868.png" alt="image-20230603170525868"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取 Redis 的 key，锁名称</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 锁 token，用于唯一标识锁</span></span><br><span class="line"><span class="keyword">local</span> token = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">-- 锁过期时间</span></span><br><span class="line"><span class="keyword">local</span> ttl = ARGV[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尝试创建新的锁</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;setnx&#x27;</span>, key, token) == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 如果锁创建成功，直接为其设置过期时间</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;expire&#x27;</span>, key, ttl)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment">-- 如果锁创建失败，表示已经有其他客户端持有了锁，则直接返回 0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>（lua中数组下标从1开始）</p><p>这个脚本会首先通过 setnx 命令来尝试创建一个新锁，如果成功创建，就立即使用 expire 命令为该锁设置过期时间。如果无法创建，表示有其他客户端已经创建了锁，则直接返回 0。</p><p>这个脚本保证了创建锁和设置过期时间的原子性，避免了上述的原子性问题。同时也需要注意设置合适的过期时间，避免锁长时间存在而导致其他客户端一直获取不到锁的问题。</p><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>前面自己实现的分布式🔒的问题：</p><p><img src="/2023/06/01/Redis/image-20230603182233390.png" alt="image-20230603182233390"></p><p><strong>解决方法：使用Redisson</strong></p><p>Redisson是一个基于Redis协议的Java客户端，提供了丰富的分布式对象和服务，如分布式集合、分布式映射、分布式锁、分布式双向队列等。Redisson的目标是为Java开发者提供方便、高效、简洁的分布式解决方案，它支持Java 8和以上版本，提供了使用简单的API，可以与Redis集群和哨兵模式集成，还能够与Spring框架完美协作，为企业级应用提供高效的缓存和分布式存储支持。</p><p><img src="/2023/06/01/Redis/image-20230607161639441.png" alt="image-20230607161639441"></p><h2 id="redis消息队列"><a href="#redis消息队列" class="headerlink" title="redis消息队列"></a>redis消息队列</h2><p><img src="/2023/06/01/Redis/image-20230608131020594.png" alt="image-20230608131020594"></p><p><img src="/2023/06/01/Redis/image-20230609102138678.png" alt="image-20230609102138678"></p><h3 id="基于List"><a href="#基于List" class="headerlink" title="基于List"></a>基于List</h3><p><img src="/2023/06/01/Redis/image-20230608131207572.png" alt="image-20230608131207572"></p><p><img src="/2023/06/01/Redis/image-20230608131520406.png" alt="image-20230608131520406"></p><h3 id="基于PubSub："><a href="#基于PubSub：" class="headerlink" title="基于PubSub："></a>基于PubSub：</h3><p><img src="/2023/06/01/Redis/image-20230608132336275.png" alt="image-20230608132336275"></p><p><img src="/2023/06/01/Redis/image-20230608132748613.png" alt="image-20230608132748613"></p><h3 id="基于Stream的单消费模式"><a href="#基于Stream的单消费模式" class="headerlink" title="基于Stream的单消费模式"></a>基于Stream的单消费模式</h3><p><img src="/2023/06/01/Redis/image-20230608133317238.png" alt="image-20230608133317238"></p><p><img src="/2023/06/01/Redis/image-20230608141712559.png" alt="image-20230608141712559"></p><p><img src="/2023/06/01/Redis/image-20230608142208216.png" alt="image-20230608142208216"></p><p><img src="/2023/06/01/Redis/image-20230608142256001.png" alt="image-20230608142256001"></p><h3 id="基于Stream的消费者组模式"><a href="#基于Stream的消费者组模式" class="headerlink" title="基于Stream的消费者组模式"></a>基于Stream的消费者组模式</h3><p><img src="/2023/06/01/Redis/image-20230609100925642.png" alt="image-20230609100925642"></p><p><img src="/2023/06/01/Redis/image-20230609101106228.png" alt="image-20230609101106228"></p><p><img src="/2023/06/01/Redis/image-20230609101830477.png" alt="image-20230609101830477"></p><p><img src="/2023/06/01/Redis/image-20230609102028270.png" alt="image-20230609102028270"></p>]]></content>
      
      
      <categories>
          
          <category> java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/2023/05/06/nginx/"/>
      <url>/2023/05/06/nginx/</url>
      
        <content type="html"><![CDATA[<p>http服务器，可以把前端工程放在上面，并且配置域名等，还可以配置反向代理，负载均衡，联通后端服务器</p><img src="/2023/05/06/nginx/image-20230506224457382.png" class="" title="image-20230506224457382"><p>配置文件大概结构：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局块</span></span><br><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="string">worker_processes</span>  <span class="number">1</span><span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#event块</span></span><br><span class="line"><span class="string">events</span> &#123;</span><br><span class="line">    <span class="string">worker_connections</span>  <span class="number">1024</span><span class="string">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#http块</span></span><br><span class="line"><span class="string">http</span> &#123;</span><br><span class="line">    <span class="comment">#http全局块</span></span><br><span class="line">    <span class="string">include</span>       <span class="string">mime.types;</span></span><br><span class="line">    <span class="string">default_type</span>  <span class="string">application/octet-stream;</span></span><br><span class="line">    <span class="string">sendfile</span>        <span class="string">on;</span></span><br><span class="line">    <span class="string">keepalive_timeout</span>  <span class="number">65</span><span class="string">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">upstream</span> <span class="string">site</span> &#123; <span class="comment">#服务器群</span></span><br><span class="line">    <span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9999;</span></span><br><span class="line">    <span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8888;</span></span><br><span class="line">    <span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7779;</span></span><br><span class="line">    <span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:7777;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#server块</span></span><br><span class="line">    <span class="string">server</span> &#123;</span><br><span class="line">        <span class="comment">#server全局块</span></span><br><span class="line">        <span class="string">listen</span>       <span class="number">8000</span><span class="string">;</span></span><br><span class="line">        <span class="string">server_name</span>  <span class="string">localhost;</span></span><br><span class="line">        <span class="comment">#location块</span></span><br><span class="line">        <span class="string">location</span> <span class="string">/</span> &#123;</span><br><span class="line">            <span class="string">root</span>   <span class="string">html;</span></span><br><span class="line">            <span class="string">index</span>  <span class="string">index.html</span> <span class="string">index.htm;</span></span><br><span class="line">            <span class="string">proxy_pass</span> <span class="string">http://site;</span>  <span class="comment">#配置上面的服务器群</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  <span class="string">/50x.html;</span></span><br><span class="line">        <span class="string">location</span> <span class="string">=</span> <span class="string">/50x.html</span> &#123;</span><br><span class="line">            <span class="string">root</span>   <span class="string">html;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#这边可以有多个server块</span></span><br><span class="line">    <span class="string">server</span> &#123;</span><br><span class="line">      <span class="string">...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p>1.[Nginx配置文件详解 - 程序员自由之路 - 博客园 (cnblogs.com)](<a href="https://www.cnblogs.com/54chensongxia/p/12938929.html#:~:text=Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">https://www.cnblogs.com/54chensongxia/p/12938929.html#:~:text=Nginx配置文件详解</a>. Nginx的主配置文件是nginx.conf，这个配置文件一共由三部分组成，分别为 全局块、events块和http块 。. 在http块中，又包含http全局块、多个server块。.,每个server块中，可以包含server全局块和多个location块。. 在同一配置块中嵌套的配置块，各个之间不存在次序关系。. 配置文件支持大量可配置的指令，绝大多数指令不是特定属于某一个块的。. 同一个指令放在不同层级的块中，其作用域也不同，一般情况下，高一级块中的指令可以作用于自身所在的块和此块包含的所有低层级块。. 如果某个指令在两个不同层级的块中同时出现，则采用”就近原则”，即以较低层级块中的配置为准。.)</p><p>2.<a href="https://www.cnblogs.com/slei212/p/10620323.html">Nginx 配置多台服务器及反向代理 - 雷先森o - 博客园 (cnblogs.com)</a></p><p>3.<a href="https://www.jianshu.com/p/8671c40a5be8">Nginx的upstream详解 - 简书 (jianshu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务</title>
      <link href="/2023/04/27/%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/04/27/%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>事务是指一组操作，被视为一个单独的、不可分割的工作单元，它要么完全执行，要么完全不执行。事务主要是为了确保数据库操作的一致性和可靠性，可以避免由于并发操作而导致的数据不一致的问题。</p><p>在关系型数据库中，事务通常具有四个特性，也被称为ACID特性：</p><ol><li>Atomicity（原子性）：事务是一个不可分割的工作单元，要么全部执行成功，要么全部执行失败，不存在部分执行成功或失败的情况。</li><li>Consistency（一致性）：事务执行前和执行后，数据库的状态必须保持一致。</li><li>Isolation（隔离性）：事务的执行不能相互影响，一个事务的执行结果不能被其他事务看到，直到事务提交。</li><li>Durability（持久性）：一旦事务提交，其执行结果就是永久性的，即使系统发生故障也不会丢失。</li></ol><p>在Java中，事务可以通过使用Spring事务管理器来实现。使用Spring事务管理器，我们可以通过注解的方式将一个方法标记为事务性的，这样在执行该方法时，<strong>如果发生异常，则会回滚所有操作</strong>。在Spring中，使用<font color="red">@Transactional</font>注解可以将一个方法标记为事务性的。同时，Spring还提供了多种事务传播属性和隔离级别的设置，以便我们根据需要进行配置。</p><p>如果只对单表进行<font color="orange">读操作，通常不需要添加事务</font>。但如果操作包括对单表进行的<font color="orange">写操作，即使只有一张表，建议添加事务</font>以确保数据的一致性和完整性。此外，如果<font color="orange">多个操作需要保证原子性（要么全部成功，要么全部失败），也需要添加事务</font>。</p><p><font color="red">@Transactional注解只有在AOP代理对象调用的情况下才能生效</font>。通过@Autowire注入的bean则都是代理对象</p><img src="/2023/04/27/%E4%BA%8B%E5%8A%A1/image-20230427141502411.png" class="" title="image-20230427141502411">]]></content>
      
      
      <categories>
          
          <category> java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybaitsplus分页插件原理</title>
      <link href="/2023/04/18/mybaitsplus%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86/"/>
      <url>/2023/04/18/mybaitsplus%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>分页插件的原理:<br>首先分页参数放到ThreadLocal中，拦截执行的sql,根据数据库类型添加对应的分页语句重写sq|，例如: <font color=" #FFA500">(select * from table where a) </font> 转换为 <font color="#FFA500">(select count(*) from table where a)</font> 和 <font color="#FFA500">(select * from table where a limit )  </font></p><p>计算出了total总条数、pageNum当前第几页、pageSize每页大小和当前页的数据，是否为首页，是否为尾页，总页数等。</p><img src="logo.svg" alt="img" style="zoom: 25%;" />]]></content>
      
      
      <categories>
          
          <category> java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybaitsplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitee提交无贡献以及恢复历史提交贡献度解决方案</title>
      <link href="/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="无贡献解决方案"><a href="#无贡献解决方案" class="headerlink" title="无贡献解决方案"></a>无贡献解决方案</h1><p>gitee提交的贡献度计算需要本地和远程的用户名&amp;提交邮箱对应上，如果对应不上就无法计算贡献。</p><img src="/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230403104335728.png" class="" title="image-20230403104335728"><p>只需要在设置-邮箱管理把提交邮箱设置和本地相同即可。后面就能有贡献了</p><h1 id="恢复历史提交贡献解决方案"><a href="#恢复历史提交贡献解决方案" class="headerlink" title="恢复历史提交贡献解决方案"></a>恢复历史提交贡献解决方案</h1><p>针对之前提交的，如果想恢复，有一下两步：</p><p>1.在项目目录下右键使用git bash here（确保安装了git），然后输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter &#x27;</span><br><span class="line">OLD_EMAIL=&quot;原来的邮箱&quot;</span><br><span class="line">CORRECT_NAME=&quot;现在的名字&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;现在的邮箱&quot;</span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&#x27; --tag-name-filter cat -- --branches --tags</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.强制推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230403105242953.png" class="" title="image-20230403105242953"><h2 id="上方法失效时："><a href="#上方法失效时：" class="headerlink" title="上方法失效时："></a>上方法失效时：</h2><p><strong>注：</strong>有些时候因为一些原因，可能造成本地与远端信息相同（本地可使用git log查看提交信息），但是依然无法恢复。可按照以下处理：</p><p>1.更改本地邮箱为错误邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter &#x27;</span><br><span class="line">OLD_EMAIL=&quot;通过git log查出来的邮箱&quot;</span><br><span class="line">CORRECT_NAME=&quot;现在的名字&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;随便填一个邮箱（不可以与远程邮箱相同）&quot;</span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&#x27; --tag-name-filter cat -- --branches --tags</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.强制推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>3.更改本地邮箱为正确邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter &#x27;</span><br><span class="line">OLD_EMAIL=&quot;第一步中随便填的邮箱&quot;</span><br><span class="line">CORRECT_NAME=&quot;现在的名字&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;现在的邮箱（远端填写的提交邮箱）&quot;</span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&#x27; --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure><p>4.强制推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><img src="/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230405081620242.png" class="" title="image-20230405081620242"><p>然后就可以成功恢复啦。</p><p>参考：<a href="https://blog.csdn.net/muxuen/article/details/129002612">【Git】如何修改本地仓库的用户名和邮箱_git修改本地仓库名_慕雪华年的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud笔记</title>
      <link href="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud相关组件-amp-对应大致功能记录"><a href="#SpringCloud相关组件-amp-对应大致功能记录" class="headerlink" title="SpringCloud相关组件&amp;对应大致功能记录"></a>SpringCloud相关组件&amp;对应大致功能记录</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a><strong><font color=red>Eureka</font></strong></h2><p>Eureka 是 Netflix 公司开源的一款服务发现框架，用于实现微服务架构中的服务注册与发现。它提供了一种简单的方式，让微服务应用可以自动地注册自己的信息（如 IP 地址、端口号、服务名称等），并通过 Eureka 服务器进行管理和发现。</p><p>在 Eureka 中，每一个微服务应用都可以作为一个服务实例，注册到 Eureka 服务器上。服务实例可以动态地进行注册、下线、心跳等操作，同时 Eureka 服务器也会自动地检查这些服务实例的状态，并提供服务发现的接口，让其他服务消费者能够轻松地发现和访问这些服务。</p><p>Eureka 的架构中包含两个核心组件：Eureka 服务器和 Eureka 客户端。Eureka 服务器负责管理所有的服务实例信息，而 Eureka 客户端则负责将自己注册到 Eureka 服务器上，并向服务器发送心跳包以保持自己的状态更新。</p><p>Eureka 的主要特点包括：</p><ul><li>易于使用和扩展：Eureka 提供了简单的 RESTful API 接口，易于使用和扩展，可以与其他技术和框架结合使用。</li><li>高可用和可靠性：Eureka 的服务器集群具有高可用性和可靠性，可以防止单点故障，并提供自我修复和自我保护机制。</li><li>实时的服务发现：Eureka 的客户端实时地向服务器更新自己的状态，并提供实时的服务发现和负载均衡功能。</li><li>易于集成和配置：Eureka 可以与其他微服务组件和技术（如 Spring Cloud、Zuul、Ribbon 等）轻松集成，也提供了丰富的配置选项和扩展点。</li></ul><p>总的来说，Eureka 是实现微服务架构中服务注册和发现的重要组件之一，具有简单、可靠、实时和易于扩展等特点，是微服务架构中不可或缺的一部分</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230331153054473.png" class="" title="image-20230331153054473"><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a><strong><font color=red>Ribbon</font></strong></h2><p>是 <em><strong><font color=green>@LoadBalanced</font></strong></em>   进行负载均衡的原理。</p><p>使用 LoadBalanced 注解可以将 RestTemplate 实例变成一个 Ribbon 负载均衡客户端。Ribbon 是 Spring Cloud 中实现负载均衡的一个组件，它可以根据特定的负载均衡策略，将请求分发到不同的服务实例上。</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230331153426859.png" class="" title="image-20230331153426859"><p>实际流程中简单来说就是<strong>先对请求进行拦截，根据请求的url找到服务名，然后去eureka中拉取服务列表，然后使用负载均衡策略进行列表服务器url选择，然后向真正的url去请求数据</strong></p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230331154757221.png" class="" title="image-20230331154757221"><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a><strong><font color=red>Nacos</font></strong></h2><p>与eureka类型，但比eureka功能更多。</p><p>默认账号&amp;密码都是”nacos”</p><p><strong>nacos与eureka区别：</strong></p><p>1.服务提供者分为临时实例（默认）与非临时实例，采用不同方式来检测是否还存活</p><p>2.服务消费者不仅会定时拉取服务pull（与eureka相同），注册中心还会主动推送变更消息</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230401124217085.png" class="" title="image-20230401124217085"><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230401123720372.png" class="" title="image-20230401123720372"><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a><strong><font color=red>Feign</font></strong></h2><p>用来代替restTemplate，使用上类似于springboot调用的controller层</p><p>最佳实践实现： 把本身在一个客户端中写的调用服务端的代码单独提出来放入一个module中统一管理，便于调用的复用</p><h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a><strong><font color=red>Gateway</font></strong></h2><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230407132203201.png" class="" title="image-20230407132203201"><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230407132111887.png" class="" title="image-20230407132111887"><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><strong><font color=red>Docker</font></strong></h2><p>Docker 是一个开源的容器化平台，可以让应用程序和其依赖项以容器的方式打包和部署。Docker 提供了一种基于容器的虚拟化解决方案，使得应用程序可以在任何平台上以相同的方式运行，无论是开发、测试、生产环境或者云上。</p><p>Docker 架构主要由三个组件组成：</p><ol><li>Docker 客户端：用户与 Docker 交互的命令行工具或者 GUI 工具。</li><li>Docker 镜像：Docker 应用程序打包和分发的标准格式，包含应用程序代码、运行时环境、系统工具、库文件等所有依赖项。</li><li>Docker 容器：Docker 镜像的运行实例，即镜像在运行时的状态。</li></ol><p>Docker 的优点：</p><ol><li>简化应用部署和管理：Docker 可以将应用程序和依赖项以容器的形式打包和分发，可以轻松地在不同的环境中部署和管理应用程序。</li><li>提高开发效率：Docker 可以在开发环境中快速部署和运行应用程序，可以减少环境配置和依赖项管理的工作量。</li><li>节省资源：Docker 容器的启动和停止非常快速，占用的系统资源非常少，可以在同一台机器上运行多个容器，提高资源利用率。</li><li>支持跨平台：Docker 可以在任何平台上运行，使得应用程序可以在不同的环境中以相同的方式运行。</li></ol><p>总的来说，Docker 提供了一种简单、轻量、可移植、可扩展的容器化解决方案，使得应用程序可以快速、可靠地部署和运行。</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230407160526996.png" class="" title="image-20230407160526996"><h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a><strong><font color=red>ES</font></strong></h2><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230410102617110.png" class="" title="image-20230410102617110"><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230410102652711.png" class="" title="image-20230410102652711"><p>如下图所示：</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230410102634357.png" class="" title="image-20230410102634357">]]></content>
      
      
      <categories>
          
          <category> java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni.shotoast真机不显示</title>
      <link href="/2023/03/31/uni-shotoast%E7%9C%9F%E6%9C%BA%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
      <url>/2023/03/31/uni-shotoast%E7%9C%9F%E6%9C%BA%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>uni.shotoast微信小程序真机不显示，貌似是说与wx控件冲突了</p><p>解决方法：使用uni.shotoast()前使用uni.hideLoading()</p><p><a href="https://blog.csdn.net/weixin_39520640/article/details/106692628">uni真机showToast不显示_uni.showtoast不显示_锦岁的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口-单调队列</title>
      <link href="/2023/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2023/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素<strong>可能</strong>成为某个区间最值时才保留它。</p><p>一般在对头放最大值或者最小值。</p><p>基本流程（以最小值为例）：滑动窗口遍历数组，从队尾放入数据，若队列中从队尾到对头有比该数大的数，则弹出。在滑动窗口移动过程中，若pre指针（滑动窗口前向指针）指向的数&#x3D;&#x3D;队头元素，则该次滑动窗口移动之后弹出队头元素。</p><p>例子：<a href="https://www.lanqiao.cn/problems/2415/learning/?page=1&first_category_id=1&sort=pass_rate&category_id=3&tags=2023&difficulty=30">附近最小 - 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span> <span class="comment">//双端队列</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line"><span class="comment">//滑动窗口、单调队列</span></span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> back = <span class="number">1</span>; back &lt;= n + k; back++) <span class="comment">//从back位置开始一个个扫描添加到双端队列中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pre = back - <span class="number">2</span> * k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (back &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">back</span>() &gt; a[back])</span><br><span class="line">&#123;</span><br><span class="line">deq.<span class="built_in">pop_back</span>(); <span class="comment">//尾部大于当前添加的就弹出去</span></span><br><span class="line">&#125;</span><br><span class="line">deq.<span class="built_in">push_back</span>(a[back]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pre - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; !deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">front</span>() == a[pre - <span class="number">1</span>]) <span class="comment">//用上一次的指向来进行对比，为什么不用该次呢？因为该次pre指向元素还在窗口内。</span></span><br><span class="line">&#123;</span><br><span class="line">deq.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (back &gt; k) <span class="comment">//但是需要back到达初试位置（即1+k）之后，再进行最小值的输出</span></span><br><span class="line">cout &lt;&lt; deq.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以最大值为例的视频讲解：<a href="https://www.bilibili.com/video/BV1XS4y1p7qj/?spm_id_from=333.337.search-card.all.click&vd_source=d978901fca1f9c4ec4151a9d124fee2d">单调队列正式登场！| LeetCode：239. 滑动窗口最大值_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS扩充数位</title>
      <link href="/2022/11/14/DFS%E6%89%A9%E5%85%85%E6%95%B0%E4%BD%8D/"/>
      <url>/2022/11/14/DFS%E6%89%A9%E5%85%85%E6%95%B0%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8825">P8825 [传智杯 #3 初赛] 运气 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>题解：这里面就通过DFS来扩充数位。将上一个数*10+i然后递交给下一层DFS，以达到扩充数位，待数位到达指定长度后对其进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n, k, cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, ll sum)</span> </span>&#123;<span class="comment">//当前位数，当前搜索的数</span></span><br><span class="line"><span class="keyword">if</span> (x == n) &#123;<span class="comment">//位数到了</span></span><br><span class="line"><span class="keyword">if</span> (sum % k == <span class="number">0</span>) cnt++;<span class="comment">//如果满足条件就计数器加一</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) <span class="built_in">dfs</span>(x + <span class="number">1</span>, sum * <span class="number">10</span> + i); <span class="comment">//位数加一，在后面补数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//从0位数，当前数为0开始搜索</span></span><br><span class="line">cout &lt;&lt; cnt % <span class="number">1000000007</span>;<span class="comment">//记得取模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传智杯-传送门</title>
      <link href="/2022/11/11/%E4%BC%A0%E6%99%BA%E6%9D%AF-%E4%BC%A0%E9%80%81%E9%97%A8/"/>
      <url>/2022/11/11/%E4%BC%A0%E6%99%BA%E6%9D%AF-%E4%BC%A0%E9%80%81%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>题目：<a href="https://www.luogu.com.cn/problem/P6464">P6464 [传智杯 #2 决赛] 传送门 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>思路：先用Floyd算法求出所有点之间的最短路径距离，得到A矩阵（由于不需要求具体路径，所有不需要Path矩阵）。然后挨个去设置开启传送门的两点。设置之后分别将两点设置为中转点，再去遍历A矩阵，更新每两个点之间的最短路径距离，然后总的和，求出所有和里面最小的那个，就是题目所求。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1e9</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">graph[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y, w;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">graph[x - <span class="number">1</span>][y - <span class="number">1</span>] = w;</span><br><span class="line">graph[y - <span class="number">1</span>][x - <span class="number">1</span>] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region Floyd算法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">graph[i][j] = <span class="built_in">min</span>(graph[i][j], graph[i][v] + graph[v][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dis = INT_MAX;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) <span class="comment">//i,j为遍历选择建立传送门的两点</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">A = graph; <span class="comment">//重置A数组</span></span><br><span class="line"></span><br><span class="line">A[i][j] = A[j][i] = <span class="number">0</span>;  <span class="comment">//设置i，j两点开启传送门，距离重置为0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以i点为中转点，更改最短路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt; n; k1++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k2 = <span class="number">0</span>; k2 &lt; n; k2++)</span><br><span class="line">A[k1][k2] = <span class="built_in">min</span>(A[k1][k2], A[k1][i] + A[i][k2]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以j点为中转点，更改最短路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt; n; k1++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k2 = <span class="number">0</span>; k2 &lt; n; k2++)</span><br><span class="line">A[k1][k2] = <span class="built_in">min</span>(A[k1][k2], A[k1][j] + A[j][k2]);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt; n; k1++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k2 = k1 + <span class="number">1</span>; k2 &lt; n; k2++)</span><br><span class="line">res += A[k1][k2];<span class="comment">//遍历矩阵的上三角或者下三角求和（因为题目说单边只统计一次）</span></span><br><span class="line">dis = <span class="built_in">min</span>(dis, res);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dis;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传智杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++取整</title>
      <link href="/2022/11/07/C++%E5%8F%96%E6%95%B4/"/>
      <url>/2022/11/07/C++%E5%8F%96%E6%95%B4/</url>
      
        <content type="html"><![CDATA[<p>C++的四舍五入函数比较：<br>对含有小数点的数进行四舍五入是比较普遍的一种需求。在C++中也有类似的取整函数。在C++的cmath头文件中有floor()和ceil()函数，还有round()函数。这三个函数的作用如下：</p><table><thead><tr><th>函数名称</th><th>函数说明</th><th>2.1</th><th>2.9</th><th>-2.1</th><th>-2.9</th></tr></thead><tbody><tr><td>floor()</td><td>向下取整</td><td>2</td><td>2</td><td>-3</td><td>-3</td></tr><tr><td>ceil()</td><td>向上取整</td><td>3</td><td>3</td><td>-2</td><td>-2</td></tr><tr><td>round()</td><td>四舍五入</td><td>2</td><td>3</td><td>-2</td><td>-3</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全排列相关问题</title>
      <link href="/2022/11/02/%E5%B1%80%E9%83%A8%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/02/%E5%B1%80%E9%83%A8%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>next_permutation：全排列</p><p>c++中的next_permutation函数用于将一个序列按照字典序重新排列成下一个更大的排列。</p><p>其原理是：</p><ol><li>从右到左扫描序列，找到第一个满足a[i] &lt; a[i+1]的位置，记为i；</li><li>从右到左扫描序列，找到第一个大于a[i]的位置j，交换a[i]和a[j]；</li><li>将序列从i+1位置开始反转，使得i+1位置到末尾的子序列变为字典序最小的序列。</li></ol><p>最后得到的序列即为下一个更大的排列。</p><p>如果已经是字典序最大的排列，则函数返回false，否则返回true。</p><p>前情提要：在做蓝桥杯马虎的算式的时候，想使用next_permutation对9个数字全排列并取出前5位数字。理论正确，结果最终结果远大于正确答案。看题解，发现问题所在：本身全排列是不会重复的，但只取9位数字前5位，前5位的组合若不加处理必然有重复情况出现。</p><p>解决方法：使用reverse(nums+5，nums+9)；</p><p><strong>例：5位取2位</strong></p><p><strong>首先不加reverse：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> nums[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//reverse(nums + 2, nums + 5);</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums, nums + <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>1.只显示两位：</p><img src="image-20221102211750905.png" alt="/image-20221102211750905" style="zoom:50%;" /><p>2.显示完全：</p><img src="image-20221102211938932.png" alt="image-20221102211938932" style="zoom: 50%;" /><p><font color=Red>可以看出很多时候都是只改变了后面几位，所以导致在取前几位的时候产生重复。</font></p><p><strong>然后加reverse结果：</strong></p><img src="image-20221102212202754.png" alt="image-20221102212202754" style="zoom:50%;" /><p>只看前两位的话会发现没有重复产生。</p><p><font color=red>原因：</font>因为全排列结果是按顺序产生的，一开始12345，在翻转后3位后成为12543，达到了12开头排序组合的最大值，所以下一次必然改变前两位。同理，13245，翻转后成为13542，下一次必然14开头。</p><p>所以使用reverse与next_permutation可以对序列取出任意不重复长度的全排列。prev_permutation同理。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> next_permutation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/2022/11/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/11/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>1.<a href="https://zhuanlan.zhihu.com/p/132823826">使用hexo新建、编辑并预览文章 - 知乎 (zhihu.com)</a></p><p>2.<a href="https://zhuanlan.zhihu.com/p/134492757">Hexo 生成永久文章链接 - 知乎 (zhihu.com)</a></p><p>3.<a href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p><p>4.<a href="https://blog.csdn.net/qq_43857095/article/details/108306164">Hexo butterfly 自定义文章封面 &amp;&amp; 主页顶部图片更改_hexo文章封面_Moqiqiuzi的博客-CSDN博客</a></p><p>5.<a href="https://blog.csdn.net/wangqingchuan92/article/details/111557770">【个人网站搭建】Hexo框架下添加README.md 及部署到 GitHub.io显示格式错误解决方法_hexo readme.md变成readme.html_wangqingchuan92的博客-CSDN博客</a></p><p>6.我的blog当前引入图片的情况下，在使用typora中image标签时，url最前面会默认有一个 <strong><font color="red">&#x2F;</font></strong> ，在typora中有或没有**&#x2F;<strong>并无影响，但是在hexo把markdown转换成html文件之后，如果有</strong>&#x2F;<strong>，则图片无法显示。所以最好手动去除该</strong>&#x2F;**</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西南交通大学840数据结构与程序设计</title>
      <link href="/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-leetcode"><a href="#1-leetcode" class="headerlink" title="1.leetcode"></a><strong>1.leetcode</strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出 x 的末尾数字 digit</span></span><br><span class="line">digit = x % <span class="number">10</span></span><br><span class="line">x /= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数字 digit 推入 rev 末尾</span></span><br><span class="line">rev = rev * <span class="number">10</span> + digit</span><br></pre></td></tr></table></figure><h2 id="例题：力扣7：回文数（逆序数字）"><a href="#例题：力扣7：回文数（逆序数字）" class="headerlink" title="例题：力扣7：回文数（逆序数字）"></a>例题：力扣7：回文数（逆序数字）</h2><p>也是西南交大2005年程序题第1题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> outcome=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> i=x%<span class="number">10</span>;   <span class="comment">//从给定数字中每次取出个位数</span></span><br><span class="line">      outcome=outcome*<span class="number">10</span>+i;  <span class="comment">//将取出的个位每次加到新给定的整数后面</span></span><br><span class="line">      x/=<span class="number">10</span>;  <span class="comment">//将给定数字整体降位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outcome&lt;INT_MIN || outcome&gt;INT_MAX?<span class="number">0</span>:outcome; <span class="comment">//判断逆置后是否超出整数范围</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-王道"><a href="#2-王道" class="headerlink" title="2.王道"></a><strong>2.王道</strong></h1><h1 id="3-天勤"><a href="#3-天勤" class="headerlink" title="3.天勤"></a><strong>3.天勤</strong></h1><h2 id="例6-1：求二叉树存储的算术表达式的值"><a href="#例6-1：求二叉树存储的算术表达式的值" class="headerlink" title="例6-1：求二叉树存储的算术表达式的值"></a>例6-1：求二叉树存储的算术表达式的值</h2><p>题目：表达式存储在二叉树中，编写算法求值。</p><img src="1628590460929.jpg" alt="1628590460929" style="zoom:25%;" /><p>分析：先求左再求右，读取根结点符号，计算值。所以采用后序遍历</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">op</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B, <span class="type">char</span> C)</span> &#123;&#125;; <span class="comment">//返回以C为运算符，以A，B为操作数的算式的数值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(BTNode* p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> A, B;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">//空树返回0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) <span class="comment">//走到叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//叶子结点，为数值，直接转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A = comp(p-&gt;lchild); <span class="comment">//后序遍历求左子树</span></span><br><span class="line">B = comp(p-&gt;rchild); <span class="comment">//后序遍历求右子树</span></span><br><span class="line"><span class="keyword">return</span> op(A, B, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例6-3：找指定结点（剪枝操作）"><a href="#例6-3：找指定结点（剪枝操作）" class="headerlink" title="例6-3：找指定结点（剪枝操作）"></a>例6-3：找指定结点（剪枝操作）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Search</span><span class="params">(BTNode* p, BTNode*&amp; q, <span class="type">int</span> key)</span> <span class="comment">//q为引用型指针，因为q要改变</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == key)</span><br><span class="line">&#123;</span><br><span class="line">q = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Search(p-&gt;lchild, q, key);</span><br><span class="line"><span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="comment">//左子树没找到才到右子树中查找，剪枝操作</span></span><br><span class="line">&#123;</span><br><span class="line">Search(p-&gt;rchild, q, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例6-3：求二叉树宽度"><a href="#例6-3：求二叉树宽度" class="headerlink" title="例6-3：求二叉树宽度"></a>例6-3：求二叉树宽度</h2><p>宽度：结点数最多一层上的结点个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //非循环队列的队列元素，存储结点指针以及层号</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BTNode* p;</span><br><span class="line"><span class="type">int</span> lno; <span class="comment">//结点层号</span></span><br><span class="line">&#125;St;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxNode</span><span class="params">(BTNode* b)</span></span><br><span class="line">&#123;</span><br><span class="line">St que[maxSize]; <span class="comment">//定义顺序非循环队列</span></span><br><span class="line"><span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Lno = <span class="number">0</span>, i, j, n, max = <span class="number">0</span>;</span><br><span class="line">BTNode* q; <span class="comment">//接收出队元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">++rear;</span><br><span class="line">que[rear].p = b; <span class="comment">//树根入队</span></span><br><span class="line">que[rear].lno = <span class="number">1</span>; <span class="comment">//层号为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (front != rear)</span><br><span class="line">&#123;</span><br><span class="line">++front;</span><br><span class="line">q = que[front].p; <span class="comment">//出队</span></span><br><span class="line">Lno = que[front].lno; <span class="comment">//获取出队元素层号信息</span></span><br><span class="line"><span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) <span class="comment">//左不空，入队</span></span><br><span class="line">&#123;</span><br><span class="line">++rear;</span><br><span class="line">que[rear].p = q-&gt;lchild;</span><br><span class="line">que[rear].lno = Lno + <span class="number">1</span>; <span class="comment">//层号+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) <span class="comment">//右不空，入队</span></span><br><span class="line">&#123;</span><br><span class="line">++rear;</span><br><span class="line">que[rear].p = q-&gt;lchild;</span><br><span class="line">que[rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Lno; i++) <span class="comment">//现在Lno数值为最大层数</span></span><br><span class="line">&#123;</span><br><span class="line">n = <span class="number">0</span>; <span class="comment">//存储每层结点个数</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; rear; j++) <span class="comment">//编列队列数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (que[j].lno == i)</span><br><span class="line">&#123;</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (max &lt; n) <span class="comment">//max存最大结点个数，读完一层比较一次</span></span><br><span class="line">&#123;</span><br><span class="line">max = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//空树，直接返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺陷：效率不太好，还可以优化</p><h2 id="习题2-1-5：填充parent域"><a href="#习题2-1-5：填充parent域" class="headerlink" title="习题2.1.5：填充parent域"></a>习题2.1.5：填充parent域</h2><p>题目：二叉树增加parent域，设计算法给每个结点parent域赋值，并输出所以结点到根结点路径</p><p>分析：给parent赋值可以在遍历时传入父节点指针</p><p>​打印路径即找到结点一直访问parent域</p><p>​打印全部路径采用遍历方式来完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span>* lchild, * rchild, * parent;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triBtree</span><span class="params">(BTNode* p, BTNode* q)</span> <span class="comment">//给各个结点parent赋值，q指向p的双亲结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;parent = q;</span><br><span class="line">q = p;</span><br><span class="line"><span class="built_in">triBtree</span>(p-&gt;lchild, q);</span><br><span class="line"><span class="built_in">triBtree</span>(p-&gt;rchild, q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(BTNode* p)</span> <span class="comment">//打印路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">p = p-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allpath</span><span class="params">(BTNode* p)</span> <span class="comment">//遍历打印全部路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printPath</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">allpath</span>(p-&gt;lchild);</span><br><span class="line"><span class="built_in">allpath</span>(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="习题2-1-7：输出指定结点层号"><a href="#习题2-1-7：输出指定结点层号" class="headerlink" title="习题2.1.7：输出指定结点层号"></a>习题2.1.7：输出指定结点层号</h2><p>分析：看书</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span>* lchild, * rchild;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L = <span class="number">1</span>; <span class="comment">//全局变量,记录层数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leno</span><span class="params">(BTNode* p, <span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++L; <span class="comment">//向下访问，层数增加</span></span><br><span class="line"><span class="built_in">leno</span>(p-&gt;lchild, x);</span><br><span class="line"><span class="built_in">leno</span>(p-&gt;rchild, x);</span><br><span class="line">--L; <span class="comment">//返回上层，层数减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="习题2-2-1：输出根结点到每个叶子结点路径"><a href="#习题2-2-1：输出根结点到每个叶子结点路径" class="headerlink" title="习题2.2.1：输出根结点到每个叶子结点路径"></a>习题2.2.1：输出根结点到每个叶子结点路径</h2><p>分析：看书</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span>* lchild, * rchild;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> pathStack[maxSize]; <span class="comment">//数组模拟路径栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allpath</span><span class="params">(BTNode* p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pathStack[top++] = p-&gt;data; <span class="comment">//向下访问结点并入栈</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) <span class="comment">//叶子结点，输出栈元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pathStack[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">allpath</span>(p-&gt;lchild);</span><br><span class="line"><span class="built_in">allpath</span>(p-&gt;rchild);</span><br><span class="line">--top; <span class="comment">//返回上层，元素退栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-西南交大2005年840程序题"><a href="#4-西南交大2005年840程序题" class="headerlink" title="4.西南交大2005年840程序题"></a><strong>4.西南交大2005年840程序题</strong></h1><h2 id="第2题：求字符串中出现整数个数"><a href="#第2题：求字符串中出现整数个数" class="headerlink" title="第2题：求字符串中出现整数个数"></a>第2题：求字符串中出现整数个数</h2><p>错误：-号在数字中间和数字末尾会输出错误</p><p>题目：输入一个字符串，内有数字和非数字字符，如b56x6g*6454er790v将其中连续数字作为一个长整型数依次存入数组a中，例：56存入a[0]，6存入a[1]。。。统计有多少整数，并输出。假设不存在溢出情况，字符串中存在“-”号要将其后数字看作负数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myatoi2</span><span class="params">(<span class="type">char</span>* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>]!=<span class="string">&#x27;-&#x27;</span>) <span class="comment">//正整数转换</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len=<span class="built_in">strlen</span>(a),i,j,n=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> bitsum;</span><br><span class="line">bitsum=a[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">bitsum*=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum+=bitsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span> &amp;&amp; a[<span class="number">1</span>]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[<span class="number">1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="comment">//正常负号转换</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="built_in">myatoi2</span>(&amp;(a[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//消除连续负号影响</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myatoi2</span>(&amp;(a[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnum</span><span class="params">(<span class="type">char</span>* str,<span class="type">int</span>* num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>,m=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[i]&lt;=<span class="string">&#x27;9&#x27;</span>||str[i]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m!=<span class="number">0</span>&amp;&amp;str[i]==<span class="string">&#x27;-&#x27;</span>) <span class="comment">//消除数字中间负号影响</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m!=<span class="number">1</span>) <span class="comment">//消除连续负号影响</span></span><br><span class="line">&#123;</span><br><span class="line">num[k++]=<span class="built_in">myatoi2</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="number">10</span>); <span class="comment">//C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</span></span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">m++;</span><br><span class="line">temp[j++]=str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((str[i<span class="number">-1</span>]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i<span class="number">-1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)) <span class="comment">//如果当前不是数字然后前一位是数字</span></span><br><span class="line">&#123;</span><br><span class="line">num[k++]=<span class="built_in">myatoi2</span>(temp);</span><br><span class="line"><span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">0</span>)</span><br><span class="line">   num[k++]=<span class="built_in">myatoi2</span>(temp); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> numarr[<span class="number">4</span>],i;</span><br><span class="line"><span class="type">char</span> *arr=<span class="string">&quot;abc---897def-67890is9876asd34jmk&quot;</span>;</span><br><span class="line"><span class="built_in">getnum</span>(arr,numarr);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,numarr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-西南交大2006年840程序题"><a href="#5-西南交大2006年840程序题" class="headerlink" title="5.西南交大2006年840程序题"></a><strong>5.西南交大2006年840程序题</strong></h1><h2 id="第2题：返回正整数指定某位数"><a href="#第2题：返回正整数指定某位数" class="headerlink" title="第2题：返回正整数指定某位数"></a>第2题：返回正整数指定某位数</h2><p>题目：编写函数Digit(int n,int k)，函数返回正整数n左起第k位数，若位数不够返回-1</p><p>例如：Digit(31415926,6)&#x3D;9</p><p>​   Digit(3141,5)&#x3D;-1</p><p>原理：将数字从低位到高位拆分一个一个放进数组，再利用数组下标来定位具体位数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Digit</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> value,index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((value=n%<span class="number">10</span>)!=<span class="number">0</span>) <span class="comment">//每次从低到高取一位数字</span></span><br><span class="line">&#123;</span><br><span class="line">ch[index]=value; </span><br><span class="line">n=n/<span class="number">10</span>; <span class="comment">//移掉最低位</span></span><br><span class="line">index++; <span class="comment">//数组指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&gt;index||k==<span class="number">0</span>) <span class="comment">//k大于数字位数或者等于0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ch[index-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第4题：统计单词"><a href="#第4题：统计单词" class="headerlink" title="第4题：统计单词"></a>第4题：统计单词</h2><p>题目：编写程序，从键盘输入一个文本文件名和一个单词，统计在文件中有多少个这样的单词（不区分大小写）</p><p>示例：输入：aBc </p><p>​文件内容（2行）：123Abc abc abcd </p><p>​ABC 7Ashd</p><p>​   输出：2</p><p>示例：输入：123aBc</p><p>​文件内容（2行）：123aBc abc 12 </p><p>​    3aBC 7Ashd</p><p>​   输出：1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">//文件中读出来的字符串</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>]; <span class="comment">//输入的字符串</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>; <span class="comment">//统计</span></span><br><span class="line">FILE *p=<span class="built_in">fopen</span>(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;suc\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter string:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(a);j++) <span class="comment">//将键盘输入的字符串变成全小写</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isupper</span>(a[j]))</span><br><span class="line">        &#123;</span><br><span class="line">a[j]+=<span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%s&quot;,a);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">feof</span>(p))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;!<span class="built_in">feof</span>(p);i++) <span class="comment">//一个一个字符读取，读到字符结束就把存放字符串的数组拿去比较</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> t=<span class="built_in">fgetc</span>(p);</span><br><span class="line"><span class="keyword">if</span>(t==<span class="string">&#x27; &#x27;</span>||t==<span class="string">&#x27;\t&#x27;</span>||t==<span class="string">&#x27;\n&#x27;</span>||<span class="built_in">feof</span>(p)) <span class="comment">//文件结尾必须也要加入判断条件并补上末尾\0，否则后面字符串比对最后一个字符会失败</span></span><br><span class="line">&#123;</span><br><span class="line">s[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isupper</span>(t)) <span class="comment">//将文本中读出来的字符串变成全小写</span></span><br><span class="line">&#123;</span><br><span class="line">t=t+<span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[i]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%s\n&quot;,s);</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(s,a)==<span class="number">0</span>) <span class="comment">//比对</span></span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fclose</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第5题：叶子节点数"><a href="#第5题：叶子节点数" class="headerlink" title="第5题：叶子节点数"></a>第5题：叶子节点数</h2><p>题目：递归求二叉树叶子结点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Num</span><span class="params">(BTNode *BT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(BT-&gt;left==<span class="literal">NULL</span> &amp;&amp; BT-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Num</span>(BT-&gt;left)+<span class="built_in">Num</span>(BT-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-西南交大2007年840程序题"><a href="#6-西南交大2007年840程序题" class="headerlink" title="6.西南交大2007年840程序题"></a><strong>6.西南交大2007年840程序题</strong></h1><h2 id="第1题：迭代求平方根"><a href="#第1题：迭代求平方根" class="headerlink" title="第1题：迭代求平方根"></a>第1题：迭代求平方根</h2><p>题目：用迭代法求a的平方根，迭代公式：x[n+1]&#x3D;(x[n]+a&#x2F;x[n]),要求前后两次绝对值差小于10的-5次方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> a,b,x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter a number(&gt;0) to get sqrt:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;x);</span><br><span class="line">a=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">while</span>((<span class="built_in">fabs</span>(a-b)&gt;<span class="number">1e-5</span>))</span><br><span class="line">&#123;</span><br><span class="line">b=a;</span><br><span class="line">a=(b+x/b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the sqrt is:%0.3lf\n&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>牛顿迭代法：大致就是通过迭代公式求a b，当a b足够接近时b值即为所求平方根</p><h2 id="第3题：求素因子乘积"><a href="#第3题：求素因子乘积" class="headerlink" title="第3题：求素因子乘积"></a>第3题：求素因子乘积</h2><p>题目：从键盘输入任意一个大于等于2的自然数m，将m写成所有素因子乘积的形式</p><p>如：输入：13                                     输出：13&#x3D;13</p><p>​                   420                                              420&#x3D;2<em>2</em>3<em>5</em>7</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x,i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter a num(&gt;=2):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>,x);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=x;i++)<span class="comment">//本身是素数的情况最大也就是本身</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(x%i==<span class="number">0</span>)   <span class="comment">//将输入数从2开始慢慢取余看能否除尽，能则除并输出除数。这里由于从2开始一个一个除，固后面i即使增加也不可能出现2的倍数，即也筛掉了合数</span></span><br><span class="line">&#123;</span><br><span class="line">x/=i;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)<span class="comment">//除i为1，即此时x为素数，i为他本身</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d*&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第5题：二叉排序树判断"><a href="#第5题：二叉排序树判断" class="headerlink" title="第5题：二叉排序树判断"></a>第5题：二叉排序树判断</h2><p>判断给定二叉树是否为二叉排序树。</p><p>王道p191 6</p><p>原理：中序遍历看是否递增有序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">KeyType preat=<span class="number">-32767</span>; <span class="comment">//全局变量，保存当前中序前驱的值，初始为-∞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">JudgeBST</span><span class="params">(BiTree bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b1,b2;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b1=<span class="built_in">JudgeBST</span>(bt-&gt;lchild); <span class="comment">//判左，左边整体没问题返回1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(b1==<span class="number">0</span> || predt&gt;=bt-&gt;data) <span class="comment">//若左子树返回0或前驱大于等于当前结点，则不是二叉排序树</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        predt=bt-&gt;data; <span class="comment">//保存当前结点关键字</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        b2=<span class="built_in">JudgeBST</span>(bt-&gt;rchild); <span class="comment">//判右，右边整体没问题返回1</span></span><br><span class="line">        <span class="keyword">return</span> b2; <span class="comment">//返回右子树结果，前面程序走完如果左子树有问题则会提前返回0，走不到这步，而走到这步表示前面左子树没问题，所以返回右子树的结果，右子树为1则整体没问题，右子树为0则右子树有问题，同时，整体也有问题。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-西南交大2008年840程序题"><a href="#7-西南交大2008年840程序题" class="headerlink" title="7.西南交大2008年840程序题"></a><strong>7.西南交大2008年840程序题</strong></h1><h2 id="第4题：求二叉树高度"><a href="#第4题：求二叉树高度" class="headerlink" title="第4题：求二叉树高度"></a>第4题：求二叉树高度</h2><p>题目：设计算法求二叉树高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历求高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="comment">//树空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    m=<span class="built_in">Depth</span>(T-&gt;lchild); <span class="comment">//左子树高度</span></span><br><span class="line">    n=<span class="built_in">Depth</span>(T-&gt;rchild); <span class="comment">//右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> (m&gt;n?m:n)+<span class="number">1</span>; <span class="comment">//回退,加上当前层高度再回退</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2012-840"><a href="#2012-840" class="headerlink" title="2012 840"></a><strong>2012 840</strong></h1><ol start="4"><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,l=<span class="number">0</span>,h=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((c=getchar())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">s[i++]=c;</span><br><span class="line">&#125;</span><br><span class="line">s[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">h=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[l++]!=s[h--])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;not hui wen\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=h)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hui wen\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8-西南交大2013年840程序题"><a href="#8-西南交大2013年840程序题" class="headerlink" title="8.西南交大2013年840程序题"></a><strong>8.西南交大2013年840程序题</strong></h1><h2 id="第2题：打印指定字符画"><a href="#第2题：打印指定字符画" class="headerlink" title="第2题：打印指定字符画"></a>第2题：打印指定字符画</h2><p>题目：打印如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>到控制台和文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n,i,j,l;</span><br><span class="line">FILE* file = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入行数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">fwrite(<span class="string">&quot; &quot;</span>, <span class="number">1</span>, <span class="number">1</span>, file);  <span class="comment">//参数：（待写入数据起始地址、写入的数据类型长度、写入次数（个数），文件指针）</span></span><br><span class="line">            <span class="comment">//fwrite以二进制形式对文件进行操作。用fwrite写入到文本中的内容，打开之后，字母可以正常显示，数字却显示“？”或是空格。以fread的方法读出，用printf打印出来是正常显示的。</span></span><br><span class="line">            <span class="comment">//这里也可以用fprintf</span></span><br><span class="line">            <span class="comment">//二进制写入会比格式化写入节省存储空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; <span class="number">2</span> * (i)+<span class="number">1</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">fwrite(<span class="string">&quot;*&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">fwrite(<span class="string">&quot;\n&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, file);</span><br><span class="line">&#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3题：为三叉链表存储结构的二叉树指定父节点"><a href="#第3题：为三叉链表存储结构的二叉树指定父节点" class="headerlink" title="第3题：为三叉链表存储结构的二叉树指定父节点"></a>第3题：为三叉链表存储结构的二叉树指定父节点</h2><p>题目：编写算法，将所有结点的双亲结点指针域正确填充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> //二叉树采用三叉链表存储</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">parent</span>;</span> <span class="comment">//双亲结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;TBTNode,*TBTPtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FillParent</span><span class="params">(TBTPtr root)</span> <span class="comment">//类似对先序遍历进行的改造</span></span><br><span class="line">&#123;</span><br><span class="line">TBTNode* temp = root;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (temp-&gt;lchild)</span><br><span class="line">&#123;</span><br><span class="line">temp-&gt;lchild-&gt;parent = temp;</span><br><span class="line">temp = temp-&gt;lchild;</span><br><span class="line">FillParent(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;rchild)</span><br><span class="line">&#123;</span><br><span class="line">temp-&gt;rchild-&gt;parent = temp;</span><br><span class="line">temp = temp-&gt;rchild;</span><br><span class="line">FillParent(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-西南交大2014年程序题"><a href="#9-西南交大2014年程序题" class="headerlink" title="9.西南交大2014年程序题"></a><strong>9.西南交大2014年程序题</strong></h1><ol><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> i=<span class="number">1</span>,j=<span class="number">1</span>,sum=<span class="number">0</span>,n=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">-6</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fabs</span>(<span class="number">4</span>*i/j)&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=<span class="number">4</span>*i/j;</span><br><span class="line">        i*=<span class="number">-1</span>;</span><br><span class="line">        j+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4f&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第2题：打印指定字符画-1"><a href="#第2题：打印指定字符画-1" class="headerlink" title="第2题：打印指定字符画"></a>第2题：打印指定字符画</h2><p>题目：打印如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">12</span><br><span class="line">123</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>到控制台和文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n,i,j,l;</span><br><span class="line">FILE* file = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入行数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;=i+<span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,j);</span><br><span class="line"><span class="built_in">fprintf</span>(file,<span class="string">&quot;%d&quot;</span>,j); <span class="comment">//将格式化的数据写入文件。与 scanf() 和 printf() 相比，它们仅仅多了一个 fp 参数。</span></span><br><span class="line">            <span class="comment">//这里不用fwrite是因为fwrite处理数字会乱码。但是能通过fread从乱码文件中获取到正确的信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(file,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3题：二叉树中查找指定结点"><a href="#第3题：二叉树中查找指定结点" class="headerlink" title="第3题：二叉树中查找指定结点"></a>第3题：二叉树中查找指定结点</h2><p>题目：二叉树中查找指定结点并返回地址，找不到返回NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BiTree <span class="title function_">Locate</span><span class="params">(BiTree bt, <span class="type">char</span> key)</span> <span class="comment">//先序遍历.可以做模板记住，整体就是 遍历并一层层返回需要的某一个元素</span></span><br><span class="line">&#123;</span><br><span class="line">BiTree p;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;data == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p = Locate(bt-&gt;lchild, key);</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Locate(bt-&gt;rchild, key); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-西南交大2017年840程序题"><a href="#10-西南交大2017年840程序题" class="headerlink" title="10.西南交大2017年840程序题"></a><strong>10.西南交大2017年840程序题</strong></h1><h2 id="第2题：存储学生信息"><a href="#第2题：存储学生信息" class="headerlink" title="第2题：存储学生信息"></a>第2题：存储学生信息</h2><p>题目：N个学生，信息有学号、姓名、三门课成绩、三门课平均分。从键盘输入前三个信息，平均分由输入算出，最后将结果存放到文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//char* stuNum;  //可以用成员指针来表示字符串，但结构体成员指针需要初始化，否则报错</span></span><br><span class="line"><span class="type">char</span> stuNum[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">float</span> score[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> avg;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">FILE* file;</span><br><span class="line">file = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学生信息数量:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">Stu* stus = (Stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu) * N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//stus[i].stuNum = (char*)malloc(sizeof(char));  //结构体成员指针初始化（无论存多少数据，初始化开辟一个对应空间即可）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入%d号学生信息(学号 姓名 三科成绩):&quot;</span>, i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %s %f %f %f&quot;</span>, stus[i].stuNum, stus[i].name, &amp;stus[i].score[<span class="number">0</span>], &amp;stus[i].score[<span class="number">1</span>], &amp;stus[i].score[<span class="number">2</span>]);</span><br><span class="line">stus[i].avg = (stus[i].score[<span class="number">0</span>] + stus[i].score[<span class="number">1</span>] + stus[i].score[<span class="number">2</span>]) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(file, <span class="string">&quot; %s %s %f %f %f %f\n&quot;</span>, stus[i].stuNum, stus[i].name, stus[i].score[<span class="number">0</span>], stus[i].score[<span class="number">1</span>], stus[i].score[<span class="number">2</span>],stus[i].avg);</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用fwrite版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="comment">//char* stuNum;  //可以用成员指针来表示字符串，但结构体成员指针需要初始化，否则报错    </span></span><br><span class="line"><span class="type">char</span> stuNum[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">float</span> score[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> avg;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">FILE* file;</span><br><span class="line">file = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学生信息数量:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">Stu* stus = (Stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu) * N);</span><br><span class="line">Stu* stus2 = (Stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu) * N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入%d号学生信息(学号 姓名 三科成绩):&quot;</span>, i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %s %f %f %f&quot;</span>, stus[i].stuNum, stus[i].name, &amp;stus[i].score[<span class="number">0</span>], &amp;stus[i].score[<span class="number">1</span>], &amp;stus[i].score[<span class="number">2</span>]);</span><br><span class="line">stus[i].avg = (stus[i].score[<span class="number">0</span>] + stus[i].score[<span class="number">1</span>] + stus[i].score[<span class="number">2</span>]) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">fwrite(stus, <span class="keyword">sizeof</span>(Stu), N, file);</span><br><span class="line">rewind(file);</span><br><span class="line">fread(stus2, <span class="keyword">sizeof</span>(Stu), N, file);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %f %f %f&quot;</span>, stus2[i].stuNum, stus2[i].name, stus2[i].score[<span class="number">0</span>], stus2[i].score[<span class="number">1</span>], stus2[i].score[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="11-西南交大2014年959程序题"><a href="#11-西南交大2014年959程序题" class="headerlink" title="11.西南交大2014年959程序题"></a><strong>11.西南交大2014年959程序题</strong></h1><h2 id="第10题（填空题）：交换二叉树左右子树"><a href="#第10题（填空题）：交换二叉树左右子树" class="headerlink" title="第10题（填空题）：交换二叉树左右子树"></a>第10题（填空题）：交换二叉树左右子树</h2><p>题目：交换二叉树左右子树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">&#125;*BiTree,BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(BiTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">BiTree temp;</span><br><span class="line">Swap(bt-&gt;lchild);</span><br><span class="line">Swap(bt-&gt;rchild);</span><br><span class="line"></span><br><span class="line">temp = bt-&gt;lchild;</span><br><span class="line">bt-&gt;lchild = bt-&gt;rchild;</span><br><span class="line">bt-&gt;rchild = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第4题：复制二叉树"><a href="#第4题：复制二叉树" class="headerlink" title="第4题：复制二叉树"></a>第4题：复制二叉树</h2><p>题目：将以t为树根二叉树复制到以bt为树根中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">struct</span> <span class="title class_">BiTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* lchild, * rchild;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">&#125;*BiTree, BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(BiTree bt, BiTree&amp; bt2)</span> <span class="comment">//只有c++有引用，引用即取别名。传指针其实只是复制了地址，从而对指向元素进行更改，但是如果向对实参指针地址进行更改则做不到</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">bt2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bt2 = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="comment">//bt2-&gt;lchild=null;</span></span><br><span class="line">    <span class="comment">//bt2-&gt;rchild=null;</span></span><br><span class="line"><span class="comment">//bt2-&gt;lchild= (BiTree)malloc(sizeof(BiTNode)); //能连接起来的本质上原因</span></span><br><span class="line">    <span class="comment">//原本一个结点就包含左右指针，但是没有赋值，无指向，在递归时将左右指针向下传递后，让其指向新申请空间，从而达到连接</span></span><br><span class="line">bt2-&gt;value = bt-&gt;value;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Copy</span>(bt-&gt;lchild, bt2-&gt;lchild); </span><br><span class="line"><span class="built_in">Copy</span>(bt-&gt;rchild, bt2-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充：引用，传值区别"><a href="#补充：引用，传值区别" class="headerlink" title="补充：引用，传值区别"></a>补充：引用，传值区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>* a)</span><span class="comment">//传指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a_v:%d\n&quot;</span>, *a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a:%p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;a:%p\n\n&quot;</span>, &amp;a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(<span class="type">int</span>*&amp; b)</span><span class="comment">//传引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b_v:%d\n&quot;</span>, *b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b:%p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;b:%p\n\n&quot;</span>, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="built_in">test</span>(p);</span><br><span class="line"><span class="built_in">test2</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p_v:%d\n&quot;</span>, *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p:%p\n&quot;</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;p:%p\n\n&quot;</span>, &amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">a_v:<span class="number">10</span>  <span class="comment">//值</span></span><br><span class="line">a:<span class="number">00F</span>8FA9C</span><br><span class="line">&amp;a:<span class="number">00F</span>8F9BC</span><br><span class="line"></span><br><span class="line">b_v:<span class="number">10</span></span><br><span class="line">b:<span class="number">00F</span>8FA9C</span><br><span class="line">&amp;b:<span class="number">00F</span>8FA90</span><br><span class="line"></span><br><span class="line">p_v:<span class="number">10</span></span><br><span class="line">p:<span class="number">00F</span>8FA9C</span><br><span class="line">&amp;p:<span class="number">00F</span>8FA90</span><br></pre></td></tr></table></figure><p>显然，bp完全相同。ap只是指向相同，ap俩指针本身地址不同。指针传递本质上也是值传递，只是由于传的是指向地址，所以局部更改能返回到全局</p><p>创建二叉树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>* <span class="title">l</span>, * <span class="title">r</span>;</span></span><br><span class="line">&#125;BiNode, * BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Create</span><span class="params">(BiTree &amp;t)</span><span class="comment">//先序创建二叉树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiNode));</span><br><span class="line">t-&gt;data = c;</span><br><span class="line">t-&gt;l = <span class="literal">NULL</span>;</span><br><span class="line">t-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">Create(t-&gt;l);</span><br><span class="line">Create(t-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(BiTree t)</span> <span class="comment">//中序遍历</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">preOrder(t-&gt;l);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, t-&gt;data);</span><br><span class="line">preOrder(t-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">BiTree t;</span><br><span class="line">Create(t);</span><br><span class="line">preOrder(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="Brian-Kernighan（可以用于清除二进制数中最右侧的1）"><a href="#Brian-Kernighan（可以用于清除二进制数中最右侧的1）" class="headerlink" title="Brian Kernighan（可以用于清除二进制数中最右侧的1）"></a>Brian Kernighan（可以用于清除二进制数中最右侧的1）</h2><p>记 f(x)表示 x 和 x-1 进行与运算所得的结果（即 f(x)&#x3D;x&amp;(x-1)，那么 f(x) 恰为 x 删去（变成0）其二进制表示中最右侧的 1 的结果。</p><h2 id="求二进制最后一位"><a href="#求二进制最后一位" class="headerlink" title="求二进制最后一位"></a>求二进制最后一位</h2><p>在循环的每一步中，我们可以使用位运算 n &amp; 1 获取 n 的最低位，判断其是否为 1。在这之后，我们将 n 右移一位：n &#x3D; n &gt;&gt; 1，这样在第 ii 步时，n &amp; 1 得到的就是初始 n 的第 i 个二进制位。</p><h1 id="整数转补码："><a href="#整数转补码：" class="headerlink" title="整数转补码："></a>整数转补码：</h1><p>对于一个正整数x，如果x的类型大小是n位的二进制数，则x的补码为：2的n次方 - x</p><p>对于一个负整数x，x的补码为2的n次方＋x</p><h1 id="找重复子串"><a href="#找重复子串" class="headerlink" title="找重复子串"></a>找重复子串</h1><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p><p>示例 1:</p><p>输入: s &#x3D; “abab”<br>输出: true<br>解释: 可由子串 “ab” 重复两次构成。<br>示例 2:</p><p>输入: s &#x3D; “aba”<br>输出: false<br>示例 3:</p><p>输入: s &#x3D; “abcabcabcabc”<br>输出: true<br>解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)</p><p>解法：我们将两个 s<em>s</em> 连在一起，并移除第一个和最后一个字符。如果 s<em>s</em> 是该字符串的子串，那么 s<em>s</em> 就满足题目要求。</p><h1 id="字符串拼接效率问题"><a href="#字符串拼接效率问题" class="headerlink" title="字符串拼接效率问题"></a>字符串拼接效率问题</h1><p>引申使用str +&#x3D; “a”， str &#x3D;str+ “a” 效率差距：</p><p>str &#x3D;str+ “a”加的运算产生的是一个新的对象，再把结果返回，而str +&#x3D; “a” 涉及到的应该是对象的引用，操作之后直接返回引用，避免了产生新的对象。因此，两者的性能有一定的差距。</p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>题目只要涉及：求大于某个数的第一个元素、下一个更大元素…这种类似的字眼的，都是单调栈的题目</p><p>对于求正因子，记住i*i&lt;num这一条件</p><h1 id="最大公因数gcd"><a href="#最大公因数gcd" class="headerlink" title="最大公因数gcd"></a>最大公因数gcd</h1><p>1.__gcd在vs内没有，devcpp内有，头文件为#include<algorithm></p><p>附上实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> __gcd(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line"><span class="keyword">auto</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a % b != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = a % b;</span><br><span class="line">a = b;</span><br><span class="line">b = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.斐波那契数列最大公约数定理gcd(Fn, Fm) &#x3D; F(gcd(n, m))</p><h1 id="关于C-x2F-C-的四舍五入机制"><a href="#关于C-x2F-C-的四舍五入机制" class="headerlink" title="关于C&#x2F;C++的四舍五入机制"></a>关于C&#x2F;C++的四舍五入机制</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%0.1f\n&quot;</span>, <span class="number">0.55</span>); <span class="comment">//结果：0.6  保留小数位会四舍五入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%0.1f\n&quot;</span>, <span class="number">0.54</span>); <span class="comment">//结果：0.5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">5</span> / <span class="number">2</span>);   <span class="comment">//结果：2    直接除则不会</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西南交大840考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/26/hello-world/"/>
      <url>/2022/10/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
