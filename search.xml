<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mybaitsplus分页插件原理</title>
      <link href="/2023/04/18/mybaitsplus%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86/"/>
      <url>/2023/04/18/mybaitsplus%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>分页插件的原理:<br>首先分页参数放到ThreadLocal中，拦截执行的sql,根据数据库类型添加对应的分页语句重写sq|,例如: (select *<br>from table where a)转换为(select count(*) from table where a)和(select * from table where a limit )<br>计算出了total总条数、pageNum当前第几页、pageSize每 页大小和当前页的数据，是否为首页，是否为尾页,总<br>页数等。</p><img src="logo.svg" alt="img" style="zoom: 25%;" />]]></content>
      
      
      <categories>
          
          <category> java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybaitsplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gitee提交无贡献以及恢复历史提交贡献度解决方案</title>
      <link href="/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="无贡献解决方案"><a href="#无贡献解决方案" class="headerlink" title="无贡献解决方案"></a>无贡献解决方案</h1><p>gitee提交的贡献度计算需要本地和远程的用户名&amp;提交邮箱对应上，如果对应不上就无法计算贡献。</p><img src="/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230403104335728.png" class="" title="image-20230403104335728"><p>只需要在设置-邮箱管理把提交邮箱设置和本地相同即可。后面就能有贡献了</p><h1 id="恢复历史提交贡献解决方案"><a href="#恢复历史提交贡献解决方案" class="headerlink" title="恢复历史提交贡献解决方案"></a>恢复历史提交贡献解决方案</h1><p>针对之前提交的，如果想恢复，有一下两步：</p><p>1.在项目目录下右键使用git bash here（确保安装了git），然后输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter &#x27;</span><br><span class="line">OLD_EMAIL=&quot;原来的邮箱&quot;</span><br><span class="line">CORRECT_NAME=&quot;现在的名字&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;现在的邮箱&quot;</span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&#x27; --tag-name-filter cat -- --branches --tags</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.强制推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>结果：</p><img src="/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230403105242953.png" class="" title="image-20230403105242953"><h2 id="上方法失效时："><a href="#上方法失效时：" class="headerlink" title="上方法失效时："></a>上方法失效时：</h2><p><strong>注：</strong>有些时候因为一些原因，可能造成本地与远端信息相同（本地可使用git log查看提交信息），但是依然无法恢复。可按照以下处理：</p><p>1.更改本地邮箱为错误邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter &#x27;</span><br><span class="line">OLD_EMAIL=&quot;通过git log查出来的邮箱&quot;</span><br><span class="line">CORRECT_NAME=&quot;现在的名字&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;随便填一个邮箱（不可以与远程邮箱相同）&quot;</span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&#x27; --tag-name-filter cat -- --branches --tags</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.强制推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><p>3.更改本地邮箱为正确邮箱</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch -f --env-filter &#x27;</span><br><span class="line">OLD_EMAIL=&quot;第一步中随便填的邮箱&quot;</span><br><span class="line">CORRECT_NAME=&quot;现在的名字&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;现在的邮箱（远端填写的提交邮箱）&quot;</span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&#x27; --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure><p>4.强制推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><img src="/2023/04/03/gitee%E6%8F%90%E4%BA%A4%E6%97%A0%E8%B4%A1%E7%8C%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230405081620242.png" class="" title="image-20230405081620242"><p>然后就可以成功恢复啦。</p><p>参考：<a href="https://blog.csdn.net/muxuen/article/details/129002612">【Git】如何修改本地仓库的用户名和邮箱_git修改本地仓库名_慕雪华年的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud笔记</title>
      <link href="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringCloud相关组件-amp-对应大致功能记录"><a href="#SpringCloud相关组件-amp-对应大致功能记录" class="headerlink" title="SpringCloud相关组件&amp;对应大致功能记录"></a>SpringCloud相关组件&amp;对应大致功能记录</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a><strong><font color=red>Eureka</font></strong></h2><p>Eureka 是 Netflix 公司开源的一款服务发现框架，用于实现微服务架构中的服务注册与发现。它提供了一种简单的方式，让微服务应用可以自动地注册自己的信息（如 IP 地址、端口号、服务名称等），并通过 Eureka 服务器进行管理和发现。</p><p>在 Eureka 中，每一个微服务应用都可以作为一个服务实例，注册到 Eureka 服务器上。服务实例可以动态地进行注册、下线、心跳等操作，同时 Eureka 服务器也会自动地检查这些服务实例的状态，并提供服务发现的接口，让其他服务消费者能够轻松地发现和访问这些服务。</p><p>Eureka 的架构中包含两个核心组件：Eureka 服务器和 Eureka 客户端。Eureka 服务器负责管理所有的服务实例信息，而 Eureka 客户端则负责将自己注册到 Eureka 服务器上，并向服务器发送心跳包以保持自己的状态更新。</p><p>Eureka 的主要特点包括：</p><ul><li>易于使用和扩展：Eureka 提供了简单的 RESTful API 接口，易于使用和扩展，可以与其他技术和框架结合使用。</li><li>高可用和可靠性：Eureka 的服务器集群具有高可用性和可靠性，可以防止单点故障，并提供自我修复和自我保护机制。</li><li>实时的服务发现：Eureka 的客户端实时地向服务器更新自己的状态，并提供实时的服务发现和负载均衡功能。</li><li>易于集成和配置：Eureka 可以与其他微服务组件和技术（如 Spring Cloud、Zuul、Ribbon 等）轻松集成，也提供了丰富的配置选项和扩展点。</li></ul><p>总的来说，Eureka 是实现微服务架构中服务注册和发现的重要组件之一，具有简单、可靠、实时和易于扩展等特点，是微服务架构中不可或缺的一部分</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230331153054473.png" class="" title="image-20230331153054473"><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a><strong><font color=red>Ribbon</font></strong></h2><p>是 <em><strong><font color=green>@LoadBalanced</font></strong></em>   进行负载均衡的原理。</p><p>使用 LoadBalanced 注解可以将 RestTemplate 实例变成一个 Ribbon 负载均衡客户端。Ribbon 是 Spring Cloud 中实现负载均衡的一个组件，它可以根据特定的负载均衡策略，将请求分发到不同的服务实例上。</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230331153426859.png" class="" title="image-20230331153426859"><p>实际流程中简单来说就是<strong>先对请求进行拦截，根据请求的url找到服务名，然后去eureka中拉取服务列表，然后使用负载均衡策略进行列表服务器url选择，然后向真正的url去请求数据</strong></p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230331154757221.png" class="" title="image-20230331154757221"><h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a><strong><font color=red>Nacos</font></strong></h2><p>与eureka类型，但比eureka功能更多。</p><p>默认账号&amp;密码都是”nacos”</p><p><strong>nacos与eureka区别：</strong></p><p>1.服务提供者分为临时实例（默认）与非临时实例，采用不同方式来检测是否还存活</p><p>2.服务消费者不仅会定时拉取服务pull（与eureka相同），注册中心还会主动推送变更消息</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230401124217085.png" class="" title="image-20230401124217085"><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230401123720372.png" class="" title="image-20230401123720372"><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a><strong><font color=red>Feign</font></strong></h2><p>用来代替restTemplate，使用上类似于springboot调用的controller层</p><p>最佳实践实现： 把本身在一个客户端中写的调用服务端的代码单独提出来放入一个module中统一管理，便于调用的复用</p><h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a><strong><font color=red>Gateway</font></strong></h2><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230407132203201.png" class="" title="image-20230407132203201"><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230407132111887.png" class="" title="image-20230407132111887"><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a><strong><font color=red>Docker</font></strong></h2><p>Docker 是一个开源的容器化平台，可以让应用程序和其依赖项以容器的方式打包和部署。Docker 提供了一种基于容器的虚拟化解决方案，使得应用程序可以在任何平台上以相同的方式运行，无论是开发、测试、生产环境或者云上。</p><p>Docker 架构主要由三个组件组成：</p><ol><li>Docker 客户端：用户与 Docker 交互的命令行工具或者 GUI 工具。</li><li>Docker 镜像：Docker 应用程序打包和分发的标准格式，包含应用程序代码、运行时环境、系统工具、库文件等所有依赖项。</li><li>Docker 容器：Docker 镜像的运行实例，即镜像在运行时的状态。</li></ol><p>Docker 的优点：</p><ol><li>简化应用部署和管理：Docker 可以将应用程序和依赖项以容器的形式打包和分发，可以轻松地在不同的环境中部署和管理应用程序。</li><li>提高开发效率：Docker 可以在开发环境中快速部署和运行应用程序，可以减少环境配置和依赖项管理的工作量。</li><li>节省资源：Docker 容器的启动和停止非常快速，占用的系统资源非常少，可以在同一台机器上运行多个容器，提高资源利用率。</li><li>支持跨平台：Docker 可以在任何平台上运行，使得应用程序可以在不同的环境中以相同的方式运行。</li></ol><p>总的来说，Docker 提供了一种简单、轻量、可移植、可扩展的容器化解决方案，使得应用程序可以快速、可靠地部署和运行。</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230407160526996.png" class="" title="image-20230407160526996"><h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a><strong><font color=red>ES</font></strong></h2><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230410102617110.png" class="" title="image-20230410102617110"><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230410102652711.png" class="" title="image-20230410102652711"><p>如下图所示：</p><img src="/2023/03/31/springcloud%E7%AC%94%E8%AE%B0/image-20230410102634357.png" class="" title="image-20230410102634357">]]></content>
      
      
      <categories>
          
          <category> java后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni.shotoast真机不显示</title>
      <link href="/2023/03/31/uni-shotoast%E7%9C%9F%E6%9C%BA%E4%B8%8D%E6%98%BE%E7%A4%BA/"/>
      <url>/2023/03/31/uni-shotoast%E7%9C%9F%E6%9C%BA%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<p>uni.shotoast微信小程序真机不显示，貌似是说与wx控件冲突了</p><p>解决方法：使用uni.shotoast()前使用uni.hideLoading()</p><p><a href="https://blog.csdn.net/weixin_39520640/article/details/106692628">uni真机showToast不显示_uni.showtoast不显示_锦岁的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> uniapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口-单调队列</title>
      <link href="/2023/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2023/03/30/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列的基本思想是，维护一个双向队列（deque），遍历序列，仅当一个元素<strong>可能</strong>成为某个区间最值时才保留它。</p><p>一般在对头放最大值或者最小值。</p><p>基本流程（以最小值为例）：滑动窗口遍历数组，从队尾放入数据，若队列中从队尾到对头有比该数大的数，则弹出。在滑动窗口移动过程中，若pre指针（滑动窗口前向指针）指向的数&#x3D;&#x3D;队头元素，则该次滑动窗口移动之后弹出队头元素。</p><p>例子：<a href="https://www.lanqiao.cn/problems/2415/learning/?page=1&first_category_id=1&sort=pass_rate&category_id=3&tags=2023&difficulty=30">附近最小 - 蓝桥云课 (lanqiao.cn)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span> <span class="comment">//双端队列</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line"><span class="comment">//滑动窗口、单调队列</span></span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> back = <span class="number">1</span>; back &lt;= n + k; back++) <span class="comment">//从back位置开始一个个扫描添加到双端队列中</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> pre = back - <span class="number">2</span> * k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (back &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">back</span>() &gt; a[back])</span><br><span class="line">&#123;</span><br><span class="line">deq.<span class="built_in">pop_back</span>(); <span class="comment">//尾部大于当前添加的就弹出去</span></span><br><span class="line">&#125;</span><br><span class="line">deq.<span class="built_in">push_back</span>(a[back]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pre - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; !deq.<span class="built_in">empty</span>() &amp;&amp; deq.<span class="built_in">front</span>() == a[pre - <span class="number">1</span>]) <span class="comment">//用上一次的指向来进行对比，为什么不用该次呢？因为该次pre指向元素还在窗口内。</span></span><br><span class="line">&#123;</span><br><span class="line">deq.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (back &gt; k) <span class="comment">//但是需要back到达初试位置（即1+k）之后，再进行最小值的输出</span></span><br><span class="line">cout &lt;&lt; deq.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以最大值为例的视频讲解：<a href="https://www.bilibili.com/video/BV1XS4y1p7qj/?spm_id_from=333.337.search-card.all.click&vd_source=d978901fca1f9c4ec4151a9d124fee2d">单调队列正式登场！| LeetCode：239. 滑动窗口最大值_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFS扩充数位</title>
      <link href="/2022/11/14/DFS%E6%89%A9%E5%85%85%E6%95%B0%E4%BD%8D/"/>
      <url>/2022/11/14/DFS%E6%89%A9%E5%85%85%E6%95%B0%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P8825">P8825 [传智杯 #3 初赛] 运气 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>题解：这里面就通过DFS来扩充数位。将上一个数*10+i然后递交给下一层DFS，以达到扩充数位，待数位到达指定长度后对其进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n, k, cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, ll sum)</span> </span>&#123;<span class="comment">//当前位数，当前搜索的数</span></span><br><span class="line"><span class="keyword">if</span> (x == n) &#123;<span class="comment">//位数到了</span></span><br><span class="line"><span class="keyword">if</span> (sum % k == <span class="number">0</span>) cnt++;<span class="comment">//如果满足条件就计数器加一</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) <span class="built_in">dfs</span>(x + <span class="number">1</span>, sum * <span class="number">10</span> + i); <span class="comment">//位数加一，在后面补数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);<span class="comment">//从0位数，当前数为0开始搜索</span></span><br><span class="line">cout &lt;&lt; cnt % <span class="number">1000000007</span>;<span class="comment">//记得取模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传智杯-传送门</title>
      <link href="/2022/11/11/%E4%BC%A0%E6%99%BA%E6%9D%AF-%E4%BC%A0%E9%80%81%E9%97%A8/"/>
      <url>/2022/11/11/%E4%BC%A0%E6%99%BA%E6%9D%AF-%E4%BC%A0%E9%80%81%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>题目：<a href="https://www.luogu.com.cn/problem/P6464">P6464 [传智杯 #2 决赛] 传送门 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>思路：先用Floyd算法求出所有点之间的最短路径距离，得到A矩阵（由于不需要求具体路径，所有不需要Path矩阵）。然后挨个去设置开启传送门的两点。设置之后分别将两点设置为中转点，再去遍历A矩阵，更新每两个点之间的最短路径距离，然后总的和，求出所有和里面最小的那个，就是题目所求。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">graph</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1e9</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">graph[i][i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y, w;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">graph[x - <span class="number">1</span>][y - <span class="number">1</span>] = w;</span><br><span class="line">graph[y - <span class="number">1</span>][x - <span class="number">1</span>] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> region Floyd算法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">graph[i][j] = <span class="built_in">min</span>(graph[i][j], graph[i][v] + graph[v][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> endregion</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dis = INT_MAX;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) <span class="comment">//i,j为遍历选择建立传送门的两点</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">A = graph; <span class="comment">//重置A数组</span></span><br><span class="line"></span><br><span class="line">A[i][j] = A[j][i] = <span class="number">0</span>;  <span class="comment">//设置i，j两点开启传送门，距离重置为0 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以i点为中转点，更改最短路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt; n; k1++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k2 = <span class="number">0</span>; k2 &lt; n; k2++)</span><br><span class="line">A[k1][k2] = <span class="built_in">min</span>(A[k1][k2], A[k1][i] + A[i][k2]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以j点为中转点，更改最短路径</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt; n; k1++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k2 = <span class="number">0</span>; k2 &lt; n; k2++)</span><br><span class="line">A[k1][k2] = <span class="built_in">min</span>(A[k1][k2], A[k1][j] + A[j][k2]);</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k1 = <span class="number">0</span>; k1 &lt; n; k1++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k2 = k1 + <span class="number">1</span>; k2 &lt; n; k2++)</span><br><span class="line">res += A[k1][k2];<span class="comment">//遍历矩阵的上三角或者下三角求和（因为题目说单边只统计一次）</span></span><br><span class="line">dis = <span class="built_in">min</span>(dis, res);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dis;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传智杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++取整</title>
      <link href="/2022/11/07/C++%E5%8F%96%E6%95%B4/"/>
      <url>/2022/11/07/C++%E5%8F%96%E6%95%B4/</url>
      
        <content type="html"><![CDATA[<p>C++的四舍五入函数比较：<br>对含有小数点的数进行四舍五入是比较普遍的一种需求。在C++中也有类似的取整函数。在C++的cmath头文件中有floor()和ceil()函数，还有round()函数。这三个函数的作用如下：</p><table><thead><tr><th>函数名称</th><th>函数说明</th><th>2.1</th><th>2.9</th><th>-2.1</th><th>-2.9</th></tr></thead><tbody><tr><td>floor()</td><td>向下取整</td><td>2</td><td>2</td><td>-3</td><td>-3</td></tr><tr><td>ceil()</td><td>向上取整</td><td>3</td><td>3</td><td>-2</td><td>-2</td></tr><tr><td>round()</td><td>四舍五入</td><td>2</td><td>3</td><td>-2</td><td>-3</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>局部全排列问题</title>
      <link href="/2022/11/02/%E5%B1%80%E9%83%A8%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/02/%E5%B1%80%E9%83%A8%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>next_permutation：全排列</p><p>前情提要：在做蓝桥杯马虎的算式的时候，想使用next_permutation对9个数字全排列并取出前5位数字。理论正确，结果最终结果远大于正确答案。看题解，发现问题所在：本身全排列是不会重复的，但只取9位数字前5位，前5位的组合若不加处理必然有重复情况出现。</p><p>解决方法：使用reverse(nums+5，nums+9)；</p><p><strong>例：5位取2位</strong></p><p><strong>首先不加reverse：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> nums[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//reverse(nums + 2, nums + 5);</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums, nums + <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>1.只显示两位：</p><img src="image-20221102211750905.png" alt="/image-20221102211750905" style="zoom:50%;" /><p>2.显示完全：</p><img src="image-20221102211938932.png" alt="image-20221102211938932" style="zoom: 50%;" /><p><font color=Red>可以看出很多时候都是只改变了后面几位，所以导致在取前几位的时候产生重复。</font></p><p><strong>然后加reverse结果：</strong></p><img src="image-20221102212202754.png" alt="image-20221102212202754" style="zoom:50%;" /><p>只看前两位的话会发现没有重复产生。</p><p><font color=red>原因：</font>因为全排列结果是按顺序产生的，一开始12345，在翻转后3位后成为12543，达到了12开头排序组合的最大值，所以下一次必然改变前两位。同理，13245，翻转后成为13542，下一次必然14开头。</p><p>所以使用reverse与next_permutation可以对序列取出任意不重复长度的全排列。prev_permutation同理。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> next_permutation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/2022/11/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/11/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>1.<a href="https://zhuanlan.zhihu.com/p/132823826">使用hexo新建、编辑并预览文章 - 知乎 (zhihu.com)</a></p><p>2.<a href="https://zhuanlan.zhihu.com/p/134492757">Hexo 生成永久文章链接 - 知乎 (zhihu.com)</a></p><p>3.<a href="https://zhuanlan.zhihu.com/p/265077468">hexo博客如何插入图片 - 知乎 (zhihu.com)</a></p><p>4.<a href="https://blog.csdn.net/qq_43857095/article/details/108306164">Hexo butterfly 自定义文章封面 &amp;&amp; 主页顶部图片更改_hexo文章封面_Moqiqiuzi的博客-CSDN博客</a></p><p>5.<a href="https://blog.csdn.net/wangqingchuan92/article/details/111557770">【个人网站搭建】Hexo框架下添加README.md 及部署到 GitHub.io显示格式错误解决方法_hexo readme.md变成readme.html_wangqingchuan92的博客-CSDN博客</a></p><p>6.我的blog当前引入图片的情况下，在使用typora中image标签时，url最前面会默认有一个 <strong><font color="red">&#x2F;</font></strong> ，在typora中有或没有**&#x2F;<strong>并无影响，但是在hexo把markdown转换成html文件之后，如果有</strong>&#x2F;<strong>，则图片无法显示。所以最好手动去除该</strong>&#x2F;**</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西南交通大学840数据结构与程序设计</title>
      <link href="/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-leetcode"><a href="#1-leetcode" class="headerlink" title="1.leetcode"></a><strong>1.leetcode</strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出 x 的末尾数字 digit</span></span><br><span class="line">digit = x % <span class="number">10</span></span><br><span class="line">x /= <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数字 digit 推入 rev 末尾</span></span><br><span class="line">rev = rev * <span class="number">10</span> + digit</span><br></pre></td></tr></table></figure><h2 id="例题：力扣7：回文数（逆序数字）"><a href="#例题：力扣7：回文数（逆序数字）" class="headerlink" title="例题：力扣7：回文数（逆序数字）"></a>例题：力扣7：回文数（逆序数字）</h2><p>也是西南交大2005年程序题第1题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> outcome=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> i=x%<span class="number">10</span>;   <span class="comment">//从给定数字中每次取出个位数</span></span><br><span class="line">      outcome=outcome*<span class="number">10</span>+i;  <span class="comment">//将取出的个位每次加到新给定的整数后面</span></span><br><span class="line">      x/=<span class="number">10</span>;  <span class="comment">//将给定数字整体降位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> outcome&lt;INT_MIN || outcome&gt;INT_MAX?<span class="number">0</span>:outcome; <span class="comment">//判断逆置后是否超出整数范围</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="2-王道"><a href="#2-王道" class="headerlink" title="2.王道"></a><strong>2.王道</strong></h1><h1 id="3-天勤"><a href="#3-天勤" class="headerlink" title="3.天勤"></a><strong>3.天勤</strong></h1><h2 id="例6-1：求二叉树存储的算术表达式的值"><a href="#例6-1：求二叉树存储的算术表达式的值" class="headerlink" title="例6-1：求二叉树存储的算术表达式的值"></a>例6-1：求二叉树存储的算术表达式的值</h2><p>题目：表达式存储在二叉树中，编写算法求值。</p><img src="1628590460929.jpg" alt="1628590460929" style="zoom:25%;" /><p>分析：先求左再求右，读取根结点符号，计算值。所以采用后序遍历</p><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">op</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B, <span class="type">char</span> C)</span> &#123;&#125;; <span class="comment">//返回以C为运算符，以A，B为操作数的算式的数值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">comp</span><span class="params">(BTNode* p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> A, B;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="comment">//空树返回0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) <span class="comment">//走到叶子结点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;data - <span class="string">&#x27;0&#x27;</span>; <span class="comment">//叶子结点，为数值，直接转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A = comp(p-&gt;lchild); <span class="comment">//后序遍历求左子树</span></span><br><span class="line">B = comp(p-&gt;rchild); <span class="comment">//后序遍历求右子树</span></span><br><span class="line"><span class="keyword">return</span> op(A, B, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例6-3：找指定结点（剪枝操作）"><a href="#例6-3：找指定结点（剪枝操作）" class="headerlink" title="例6-3：找指定结点（剪枝操作）"></a>例6-3：找指定结点（剪枝操作）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Search</span><span class="params">(BTNode* p, BTNode*&amp; q, <span class="type">int</span> key)</span> <span class="comment">//q为引用型指针，因为q要改变</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == key)</span><br><span class="line">&#123;</span><br><span class="line">q = p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Search(p-&gt;lchild, q, key);</span><br><span class="line"><span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="comment">//左子树没找到才到右子树中查找，剪枝操作</span></span><br><span class="line">&#123;</span><br><span class="line">Search(p-&gt;rchild, q, key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例6-3：求二叉树宽度"><a href="#例6-3：求二叉树宽度" class="headerlink" title="例6-3：求二叉树宽度"></a>例6-3：求二叉树宽度</h2><p>宽度：结点数最多一层上的结点个数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> //非循环队列的队列元素，存储结点指针以及层号</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">BTNode* p;</span><br><span class="line"><span class="type">int</span> lno; <span class="comment">//结点层号</span></span><br><span class="line">&#125;St;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">MaxNode</span><span class="params">(BTNode* b)</span></span><br><span class="line">&#123;</span><br><span class="line">St que[maxSize]; <span class="comment">//定义顺序非循环队列</span></span><br><span class="line"><span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Lno = <span class="number">0</span>, i, j, n, max = <span class="number">0</span>;</span><br><span class="line">BTNode* q; <span class="comment">//接收出队元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">++rear;</span><br><span class="line">que[rear].p = b; <span class="comment">//树根入队</span></span><br><span class="line">que[rear].lno = <span class="number">1</span>; <span class="comment">//层号为1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (front != rear)</span><br><span class="line">&#123;</span><br><span class="line">++front;</span><br><span class="line">q = que[front].p; <span class="comment">//出队</span></span><br><span class="line">Lno = que[front].lno; <span class="comment">//获取出队元素层号信息</span></span><br><span class="line"><span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>) <span class="comment">//左不空，入队</span></span><br><span class="line">&#123;</span><br><span class="line">++rear;</span><br><span class="line">que[rear].p = q-&gt;lchild;</span><br><span class="line">que[rear].lno = Lno + <span class="number">1</span>; <span class="comment">//层号+1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>) <span class="comment">//右不空，入队</span></span><br><span class="line">&#123;</span><br><span class="line">++rear;</span><br><span class="line">que[rear].p = q-&gt;lchild;</span><br><span class="line">que[rear].lno = Lno + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= Lno; i++) <span class="comment">//现在Lno数值为最大层数</span></span><br><span class="line">&#123;</span><br><span class="line">n = <span class="number">0</span>; <span class="comment">//存储每层结点个数</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; rear; j++) <span class="comment">//编列队列数组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (que[j].lno == i)</span><br><span class="line">&#123;</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (max &lt; n) <span class="comment">//max存最大结点个数，读完一层比较一次</span></span><br><span class="line">&#123;</span><br><span class="line">max = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//空树，直接返回0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺陷：效率不太好，还可以优化</p><h2 id="习题2-1-5：填充parent域"><a href="#习题2-1-5：填充parent域" class="headerlink" title="习题2.1.5：填充parent域"></a>习题2.1.5：填充parent域</h2><p>题目：二叉树增加parent域，设计算法给每个结点parent域赋值，并输出所以结点到根结点路径</p><p>分析：给parent赋值可以在遍历时传入父节点指针</p><p>​打印路径即找到结点一直访问parent域</p><p>​打印全部路径采用遍历方式来完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span>* lchild, * rchild, * parent;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">triBtree</span><span class="params">(BTNode* p, BTNode* q)</span> <span class="comment">//给各个结点parent赋值，q指向p的双亲结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">p-&gt;parent = q;</span><br><span class="line">q = p;</span><br><span class="line"><span class="built_in">triBtree</span>(p-&gt;lchild, q);</span><br><span class="line"><span class="built_in">triBtree</span>(p-&gt;rchild, q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printPath</span><span class="params">(BTNode* p)</span> <span class="comment">//打印路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; endl;</span><br><span class="line">p = p-&gt;parent;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allpath</span><span class="params">(BTNode* p)</span> <span class="comment">//遍历打印全部路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printPath</span>(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">allpath</span>(p-&gt;lchild);</span><br><span class="line"><span class="built_in">allpath</span>(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="习题2-1-7：输出指定结点层号"><a href="#习题2-1-7：输出指定结点层号" class="headerlink" title="习题2.1.7：输出指定结点层号"></a>习题2.1.7：输出指定结点层号</h2><p>分析：看书</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span>* lchild, * rchild;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L = <span class="number">1</span>; <span class="comment">//全局变量,记录层数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">leno</span><span class="params">(BTNode* p, <span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == x)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; L &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++L; <span class="comment">//向下访问，层数增加</span></span><br><span class="line"><span class="built_in">leno</span>(p-&gt;lchild, x);</span><br><span class="line"><span class="built_in">leno</span>(p-&gt;rchild, x);</span><br><span class="line">--L; <span class="comment">//返回上层，层数减少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="习题2-2-1：输出根结点到每个叶子结点路径"><a href="#习题2-2-1：输出根结点到每个叶子结点路径" class="headerlink" title="习题2.2.1：输出根结点到每个叶子结点路径"></a>习题2.2.1：输出根结点到每个叶子结点路径</h2><p>分析：看书</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BTNode</span>* lchild, * rchild;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line">&#125;BTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> pathStack[maxSize]; <span class="comment">//数组模拟路径栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allpath</span><span class="params">(BTNode* p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">pathStack[top++] = p-&gt;data; <span class="comment">//向下访问结点并入栈</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild == <span class="literal">NULL</span>) <span class="comment">//叶子结点，输出栈元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; pathStack[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">allpath</span>(p-&gt;lchild);</span><br><span class="line"><span class="built_in">allpath</span>(p-&gt;rchild);</span><br><span class="line">--top; <span class="comment">//返回上层，元素退栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-西南交大2005年840程序题"><a href="#4-西南交大2005年840程序题" class="headerlink" title="4.西南交大2005年840程序题"></a><strong>4.西南交大2005年840程序题</strong></h1><h2 id="第2题：求字符串中出现整数个数"><a href="#第2题：求字符串中出现整数个数" class="headerlink" title="第2题：求字符串中出现整数个数"></a>第2题：求字符串中出现整数个数</h2><p>错误：-号在数字中间和数字末尾会输出错误</p><p>题目：输入一个字符串，内有数字和非数字字符，如b56x6g*6454er790v将其中连续数字作为一个长整型数依次存入数组a中，例：56存入a[0]，6存入a[1]。。。统计有多少整数，并输出。假设不存在溢出情况，字符串中存在“-”号要将其后数字看作负数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myatoi2</span><span class="params">(<span class="type">char</span>* a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">0</span>]!=<span class="string">&#x27;-&#x27;</span>) <span class="comment">//正整数转换</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> len=<span class="built_in">strlen</span>(a),i,j,n=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> bitsum;</span><br><span class="line">bitsum=a[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len-i<span class="number">-1</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">bitsum*=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum+=bitsum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span> &amp;&amp; a[<span class="number">1</span>]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;a[<span class="number">1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>) <span class="comment">//正常负号转换</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="built_in">myatoi2</span>(&amp;(a[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//消除连续负号影响</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">myatoi2</span>(&amp;(a[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getnum</span><span class="params">(<span class="type">char</span>* str,<span class="type">int</span>* num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>,m=<span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> temp[<span class="number">10</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;str[i]&lt;=<span class="string">&#x27;9&#x27;</span>||str[i]==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m!=<span class="number">0</span>&amp;&amp;str[i]==<span class="string">&#x27;-&#x27;</span>) <span class="comment">//消除数字中间负号影响</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m!=<span class="number">1</span>) <span class="comment">//消除连续负号影响</span></span><br><span class="line">&#123;</span><br><span class="line">num[k++]=<span class="built_in">myatoi2</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="number">10</span>); <span class="comment">//C 库函数 void *memset(void *str, int c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。</span></span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">m++;</span><br><span class="line">temp[j++]=str[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((str[i<span class="number">-1</span>]&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i<span class="number">-1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>)) <span class="comment">//如果当前不是数字然后前一位是数字</span></span><br><span class="line">&#123;</span><br><span class="line">num[k++]=<span class="built_in">myatoi2</span>(temp);</span><br><span class="line"><span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">j=<span class="number">0</span>;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">0</span>)</span><br><span class="line">   num[k++]=<span class="built_in">myatoi2</span>(temp); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> numarr[<span class="number">4</span>],i;</span><br><span class="line"><span class="type">char</span> *arr=<span class="string">&quot;abc---897def-67890is9876asd34jmk&quot;</span>;</span><br><span class="line"><span class="built_in">getnum</span>(arr,numarr);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,numarr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-西南交大2006年840程序题"><a href="#5-西南交大2006年840程序题" class="headerlink" title="5.西南交大2006年840程序题"></a><strong>5.西南交大2006年840程序题</strong></h1><h2 id="第2题：返回正整数指定某位数"><a href="#第2题：返回正整数指定某位数" class="headerlink" title="第2题：返回正整数指定某位数"></a>第2题：返回正整数指定某位数</h2><p>题目：编写函数Digit(int n,int k)，函数返回正整数n左起第k位数，若位数不够返回-1</p><p>例如：Digit(31415926,6)&#x3D;9</p><p>​   Digit(3141,5)&#x3D;-1</p><p>原理：将数字从低位到高位拆分一个一个放进数组，再利用数组下标来定位具体位数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Digit</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> value,index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((value=n%<span class="number">10</span>)!=<span class="number">0</span>) <span class="comment">//每次从低到高取一位数字</span></span><br><span class="line">&#123;</span><br><span class="line">ch[index]=value; </span><br><span class="line">n=n/<span class="number">10</span>; <span class="comment">//移掉最低位</span></span><br><span class="line">index++; <span class="comment">//数组指针后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(k&gt;index||k==<span class="number">0</span>) <span class="comment">//k大于数字位数或者等于0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ch[index-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第4题：统计单词"><a href="#第4题：统计单词" class="headerlink" title="第4题：统计单词"></a>第4题：统计单词</h2><p>题目：编写程序，从键盘输入一个文本文件名和一个单词，统计在文件中有多少个这样的单词（不区分大小写）</p><p>示例：输入：aBc </p><p>​文件内容（2行）：123Abc abc abcd </p><p>​ABC 7Ashd</p><p>​   输出：2</p><p>示例：输入：123aBc</p><p>​文件内容（2行）：123aBc abc 12 </p><p>​    3aBC 7Ashd</p><p>​   输出：1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">//文件中读出来的字符串</span></span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>]; <span class="comment">//输入的字符串</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>; <span class="comment">//统计</span></span><br><span class="line">FILE *p=<span class="built_in">fopen</span>(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;err&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;suc\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter string:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="built_in">strlen</span>(a);j++) <span class="comment">//将键盘输入的字符串变成全小写</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isupper</span>(a[j]))</span><br><span class="line">        &#123;</span><br><span class="line">a[j]+=<span class="number">32</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%s&quot;,a);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">feof</span>(p))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;!<span class="built_in">feof</span>(p);i++) <span class="comment">//一个一个字符读取，读到字符结束就把存放字符串的数组拿去比较</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> t=<span class="built_in">fgetc</span>(p);</span><br><span class="line"><span class="keyword">if</span>(t==<span class="string">&#x27; &#x27;</span>||t==<span class="string">&#x27;\t&#x27;</span>||t==<span class="string">&#x27;\n&#x27;</span>||<span class="built_in">feof</span>(p)) <span class="comment">//文件结尾必须也要加入判断条件并补上末尾\0，否则后面字符串比对最后一个字符会失败</span></span><br><span class="line">&#123;</span><br><span class="line">s[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isupper</span>(t)) <span class="comment">//将文本中读出来的字符串变成全小写</span></span><br><span class="line">&#123;</span><br><span class="line">t=t+<span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line">s[i]=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%s\n&quot;,s);</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(s,a)==<span class="number">0</span>) <span class="comment">//比对</span></span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fclose</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第5题：叶子节点数"><a href="#第5题：叶子节点数" class="headerlink" title="第5题：叶子节点数"></a>第5题：叶子节点数</h2><p>题目：递归求二叉树叶子结点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Num</span><span class="params">(BTNode *BT)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BT==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(BT-&gt;left==<span class="literal">NULL</span> &amp;&amp; BT-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Num</span>(BT-&gt;left)+<span class="built_in">Num</span>(BT-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-西南交大2007年840程序题"><a href="#6-西南交大2007年840程序题" class="headerlink" title="6.西南交大2007年840程序题"></a><strong>6.西南交大2007年840程序题</strong></h1><h2 id="第1题：迭代求平方根"><a href="#第1题：迭代求平方根" class="headerlink" title="第1题：迭代求平方根"></a>第1题：迭代求平方根</h2><p>题目：用迭代法求a的平方根，迭代公式：x[n+1]&#x3D;(x[n]+a&#x2F;x[n]),要求前后两次绝对值差小于10的-5次方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> a,b,x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter a number(&gt;0) to get sqrt:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;x);</span><br><span class="line">a=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">while</span>((<span class="built_in">fabs</span>(a-b)&gt;<span class="number">1e-5</span>))</span><br><span class="line">&#123;</span><br><span class="line">b=a;</span><br><span class="line">a=(b+x/b)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the sqrt is:%0.3lf\n&quot;</span>,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>牛顿迭代法：大致就是通过迭代公式求a b，当a b足够接近时b值即为所求平方根</p><h2 id="第3题：求素因子乘积"><a href="#第3题：求素因子乘积" class="headerlink" title="第3题：求素因子乘积"></a>第3题：求素因子乘积</h2><p>题目：从键盘输入任意一个大于等于2的自然数m，将m写成所有素因子乘积的形式</p><p>如：输入：13                                     输出：13&#x3D;13</p><p>​                   420                                              420&#x3D;2<em>2</em>3<em>5</em>7</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x,i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;please enter a num(&gt;=2):&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>,x);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=x;i++)<span class="comment">//本身是素数的情况最大也就是本身</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(x%i==<span class="number">0</span>)   <span class="comment">//将输入数从2开始慢慢取余看能否除尽，能则除并输出除数。这里由于从2开始一个一个除，固后面i即使增加也不可能出现2的倍数，即也筛掉了合数</span></span><br><span class="line">&#123;</span><br><span class="line">x/=i;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)<span class="comment">//除i为1，即此时x为素数，i为他本身</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d*&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第5题：二叉排序树判断"><a href="#第5题：二叉排序树判断" class="headerlink" title="第5题：二叉排序树判断"></a>第5题：二叉排序树判断</h2><p>判断给定二叉树是否为二叉排序树。</p><p>王道p191 6</p><p>原理：中序遍历看是否递增有序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">KeyType preat=<span class="number">-32767</span>; <span class="comment">//全局变量，保存当前中序前驱的值，初始为-∞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">JudgeBST</span><span class="params">(BiTree bt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> b1,b2;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b1=<span class="built_in">JudgeBST</span>(bt-&gt;lchild); <span class="comment">//判左，左边整体没问题返回1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(b1==<span class="number">0</span> || predt&gt;=bt-&gt;data) <span class="comment">//若左子树返回0或前驱大于等于当前结点，则不是二叉排序树</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        predt=bt-&gt;data; <span class="comment">//保存当前结点关键字</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        b2=<span class="built_in">JudgeBST</span>(bt-&gt;rchild); <span class="comment">//判右，右边整体没问题返回1</span></span><br><span class="line">        <span class="keyword">return</span> b2; <span class="comment">//返回右子树结果，前面程序走完如果左子树有问题则会提前返回0，走不到这步，而走到这步表示前面左子树没问题，所以返回右子树的结果，右子树为1则整体没问题，右子树为0则右子树有问题，同时，整体也有问题。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-西南交大2008年840程序题"><a href="#7-西南交大2008年840程序题" class="headerlink" title="7.西南交大2008年840程序题"></a><strong>7.西南交大2008年840程序题</strong></h1><h2 id="第4题：求二叉树高度"><a href="#第4题：求二叉树高度" class="headerlink" title="第4题：求二叉树高度"></a>第4题：求二叉树高度</h2><p>题目：设计算法求二叉树高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历求高度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">if</span>(!T) <span class="comment">//树空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    m=<span class="built_in">Depth</span>(T-&gt;lchild); <span class="comment">//左子树高度</span></span><br><span class="line">    n=<span class="built_in">Depth</span>(T-&gt;rchild); <span class="comment">//右子树高度</span></span><br><span class="line">    <span class="keyword">return</span> (m&gt;n?m:n)+<span class="number">1</span>; <span class="comment">//回退,加上当前层高度再回退</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2012-840"><a href="#2012-840" class="headerlink" title="2012 840"></a><strong>2012 840</strong></h1><ol start="4"><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,l=<span class="number">0</span>,h=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((c=getchar())!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">s[i++]=c;</span><br><span class="line">&#125;</span><br><span class="line">s[i]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">h=i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;h)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[l++]!=s[h--])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;not hui wen\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=h)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hui wen\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8-西南交大2013年840程序题"><a href="#8-西南交大2013年840程序题" class="headerlink" title="8.西南交大2013年840程序题"></a><strong>8.西南交大2013年840程序题</strong></h1><h2 id="第2题：打印指定字符画"><a href="#第2题：打印指定字符画" class="headerlink" title="第2题：打印指定字符画"></a>第2题：打印指定字符画</h2><p>题目：打印如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>到控制台和文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n,i,j,l;</span><br><span class="line">FILE* file = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入行数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">fwrite(<span class="string">&quot; &quot;</span>, <span class="number">1</span>, <span class="number">1</span>, file);  <span class="comment">//参数：（待写入数据起始地址、写入的数据类型长度、写入次数（个数），文件指针）</span></span><br><span class="line">            <span class="comment">//fwrite以二进制形式对文件进行操作。用fwrite写入到文本中的内容，打开之后，字母可以正常显示，数字却显示“？”或是空格。以fread的方法读出，用printf打印出来是正常显示的。</span></span><br><span class="line">            <span class="comment">//这里也可以用fprintf</span></span><br><span class="line">            <span class="comment">//二进制写入会比格式化写入节省存储空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; <span class="number">2</span> * (i)+<span class="number">1</span>; l++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">fwrite(<span class="string">&quot;*&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, file);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">fwrite(<span class="string">&quot;\n&quot;</span>, <span class="number">1</span>, <span class="number">1</span>, file);</span><br><span class="line">&#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3题：为三叉链表存储结构的二叉树指定父节点"><a href="#第3题：为三叉链表存储结构的二叉树指定父节点" class="headerlink" title="第3题：为三叉链表存储结构的二叉树指定父节点"></a>第3题：为三叉链表存储结构的二叉树指定父节点</h2><p>题目：编写算法，将所有结点的双亲结点指针域正确填充</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> //二叉树采用三叉链表存储</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">parent</span>;</span> <span class="comment">//双亲结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;TBTNode,*TBTPtr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">FillParent</span><span class="params">(TBTPtr root)</span> <span class="comment">//类似对先序遍历进行的改造</span></span><br><span class="line">&#123;</span><br><span class="line">TBTNode* temp = root;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (temp-&gt;lchild)</span><br><span class="line">&#123;</span><br><span class="line">temp-&gt;lchild-&gt;parent = temp;</span><br><span class="line">temp = temp-&gt;lchild;</span><br><span class="line">FillParent(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp-&gt;rchild)</span><br><span class="line">&#123;</span><br><span class="line">temp-&gt;rchild-&gt;parent = temp;</span><br><span class="line">temp = temp-&gt;rchild;</span><br><span class="line">FillParent(temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-西南交大2014年程序题"><a href="#9-西南交大2014年程序题" class="headerlink" title="9.西南交大2014年程序题"></a><strong>9.西南交大2014年程序题</strong></h1><ol><li></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> i=<span class="number">1</span>,j=<span class="number">1</span>,sum=<span class="number">0</span>,n=<span class="built_in">pow</span>(<span class="number">10</span>,<span class="number">-6</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fabs</span>(<span class="number">4</span>*i/j)&gt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=<span class="number">4</span>*i/j;</span><br><span class="line">        i*=<span class="number">-1</span>;</span><br><span class="line">        j+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4f&quot;</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第2题：打印指定字符画-1"><a href="#第2题：打印指定字符画-1" class="headerlink" title="第2题：打印指定字符画"></a>第2题：打印指定字符画</h2><p>题目：打印如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">12</span><br><span class="line">123</span><br><span class="line">1234</span><br></pre></td></tr></table></figure><p>到控制台和文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n,i,j,l;</span><br><span class="line">FILE* file = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入行数：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;=i+<span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,j);</span><br><span class="line"><span class="built_in">fprintf</span>(file,<span class="string">&quot;%d&quot;</span>,j); <span class="comment">//将格式化的数据写入文件。与 scanf() 和 printf() 相比，它们仅仅多了一个 fp 参数。</span></span><br><span class="line">            <span class="comment">//这里不用fwrite是因为fwrite处理数字会乱码。但是能通过fread从乱码文件中获取到正确的信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(file,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3题：二叉树中查找指定结点"><a href="#第3题：二叉树中查找指定结点" class="headerlink" title="第3题：二叉树中查找指定结点"></a>第3题：二叉树中查找指定结点</h2><p>题目：二叉树中查找指定结点并返回地址，找不到返回NULL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">lchild</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BiTree <span class="title function_">Locate</span><span class="params">(BiTree bt, <span class="type">char</span> key)</span> <span class="comment">//先序遍历.可以做模板记住，整体就是 遍历并一层层返回需要的某一个元素</span></span><br><span class="line">&#123;</span><br><span class="line">BiTree p;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bt-&gt;data == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p = Locate(bt-&gt;lchild, key);</span><br><span class="line"><span class="keyword">if</span> (p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Locate(bt-&gt;rchild, key); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-西南交大2017年840程序题"><a href="#10-西南交大2017年840程序题" class="headerlink" title="10.西南交大2017年840程序题"></a><strong>10.西南交大2017年840程序题</strong></h1><h2 id="第2题：存储学生信息"><a href="#第2题：存储学生信息" class="headerlink" title="第2题：存储学生信息"></a>第2题：存储学生信息</h2><p>题目：N个学生，信息有学号、姓名、三门课成绩、三门课平均分。从键盘输入前三个信息，平均分由输入算出，最后将结果存放到文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//char* stuNum;  //可以用成员指针来表示字符串，但结构体成员指针需要初始化，否则报错</span></span><br><span class="line"><span class="type">char</span> stuNum[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">float</span> score[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> avg;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">FILE* file;</span><br><span class="line">file = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学生信息数量:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line"></span><br><span class="line">Stu* stus = (Stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu) * N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//stus[i].stuNum = (char*)malloc(sizeof(char));  //结构体成员指针初始化（无论存多少数据，初始化开辟一个对应空间即可）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入%d号学生信息(学号 姓名 三科成绩):&quot;</span>, i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %s %f %f %f&quot;</span>, stus[i].stuNum, stus[i].name, &amp;stus[i].score[<span class="number">0</span>], &amp;stus[i].score[<span class="number">1</span>], &amp;stus[i].score[<span class="number">2</span>]);</span><br><span class="line">stus[i].avg = (stus[i].score[<span class="number">0</span>] + stus[i].score[<span class="number">1</span>] + stus[i].score[<span class="number">2</span>]) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(file, <span class="string">&quot; %s %s %f %f %f %f\n&quot;</span>, stus[i].stuNum, stus[i].name, stus[i].score[<span class="number">0</span>], stus[i].score[<span class="number">1</span>], stus[i].score[<span class="number">2</span>],stus[i].avg);</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用fwrite版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stu</span> &#123;</span></span><br><span class="line"><span class="comment">//char* stuNum;  //可以用成员指针来表示字符串，但结构体成员指针需要初始化，否则报错    </span></span><br><span class="line"><span class="type">char</span> stuNum[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">float</span> score[<span class="number">3</span>];</span><br><span class="line"><span class="type">float</span> avg;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">FILE* file;</span><br><span class="line">file = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;学生信息数量:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">Stu* stus = (Stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu) * N);</span><br><span class="line">Stu* stus2 = (Stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stu) * N);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n输入%d号学生信息(学号 姓名 三科成绩):&quot;</span>, i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s %s %f %f %f&quot;</span>, stus[i].stuNum, stus[i].name, &amp;stus[i].score[<span class="number">0</span>], &amp;stus[i].score[<span class="number">1</span>], &amp;stus[i].score[<span class="number">2</span>]);</span><br><span class="line">stus[i].avg = (stus[i].score[<span class="number">0</span>] + stus[i].score[<span class="number">1</span>] + stus[i].score[<span class="number">2</span>]) / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">fwrite(stus, <span class="keyword">sizeof</span>(Stu), N, file);</span><br><span class="line">rewind(file);</span><br><span class="line">fread(stus2, <span class="keyword">sizeof</span>(Stu), N, file);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %s %f %f %f&quot;</span>, stus2[i].stuNum, stus2[i].name, stus2[i].score[<span class="number">0</span>], stus2[i].score[<span class="number">1</span>], stus2[i].score[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">fclose(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="11-西南交大2014年959程序题"><a href="#11-西南交大2014年959程序题" class="headerlink" title="11.西南交大2014年959程序题"></a><strong>11.西南交大2014年959程序题</strong></h1><h2 id="第10题（填空题）：交换二叉树左右子树"><a href="#第10题（填空题）：交换二叉树左右子树" class="headerlink" title="第10题（填空题）：交换二叉树左右子树"></a>第10题（填空题）：交换二叉树左右子树</h2><p>题目：交换二叉树左右子树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>* <span class="title">lchild</span>, * <span class="title">rchild</span>;</span></span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">&#125;*BiTree,BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(BiTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">BiTree temp;</span><br><span class="line">Swap(bt-&gt;lchild);</span><br><span class="line">Swap(bt-&gt;rchild);</span><br><span class="line"></span><br><span class="line">temp = bt-&gt;lchild;</span><br><span class="line">bt-&gt;lchild = bt-&gt;rchild;</span><br><span class="line">bt-&gt;rchild = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第4题：复制二叉树"><a href="#第4题：复制二叉树" class="headerlink" title="第4题：复制二叉树"></a>第4题：复制二叉树</h2><p>题目：将以t为树根二叉树复制到以bt为树根中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span><span class="keyword">struct</span> <span class="title class_">BiTNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BiTNode</span>* lchild, * rchild;</span><br><span class="line"><span class="type">int</span> value;</span><br><span class="line">&#125;*BiTree, BiTNode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Copy</span><span class="params">(BiTree bt, BiTree&amp; bt2)</span> <span class="comment">//只有c++有引用，引用即取别名。传指针其实只是复制了地址，从而对指向元素进行更改，但是如果向对实参指针地址进行更改则做不到</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bt == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">bt2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">bt2 = (BiTree)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="comment">//bt2-&gt;lchild=null;</span></span><br><span class="line">    <span class="comment">//bt2-&gt;rchild=null;</span></span><br><span class="line"><span class="comment">//bt2-&gt;lchild= (BiTree)malloc(sizeof(BiTNode)); //能连接起来的本质上原因</span></span><br><span class="line">    <span class="comment">//原本一个结点就包含左右指针，但是没有赋值，无指向，在递归时将左右指针向下传递后，让其指向新申请空间，从而达到连接</span></span><br><span class="line">bt2-&gt;value = bt-&gt;value;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Copy</span>(bt-&gt;lchild, bt2-&gt;lchild); </span><br><span class="line"><span class="built_in">Copy</span>(bt-&gt;rchild, bt2-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充：引用，传值区别"><a href="#补充：引用，传值区别" class="headerlink" title="补充：引用，传值区别"></a>补充：引用，传值区别</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span>* a)</span><span class="comment">//传指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a_v:%d\n&quot;</span>, *a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a:%p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;a:%p\n\n&quot;</span>, &amp;a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test2</span><span class="params">(<span class="type">int</span>*&amp; b)</span><span class="comment">//传引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b_v:%d\n&quot;</span>, *b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b:%p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;b:%p\n\n&quot;</span>, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"><span class="built_in">test</span>(p);</span><br><span class="line"><span class="built_in">test2</span>(p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p_v:%d\n&quot;</span>, *p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p:%p\n&quot;</span>, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;&amp;p:%p\n\n&quot;</span>, &amp;p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">a_v:<span class="number">10</span>  <span class="comment">//值</span></span><br><span class="line">a:<span class="number">00F</span>8FA9C</span><br><span class="line">&amp;a:<span class="number">00F</span>8F9BC</span><br><span class="line"></span><br><span class="line">b_v:<span class="number">10</span></span><br><span class="line">b:<span class="number">00F</span>8FA9C</span><br><span class="line">&amp;b:<span class="number">00F</span>8FA90</span><br><span class="line"></span><br><span class="line">p_v:<span class="number">10</span></span><br><span class="line">p:<span class="number">00F</span>8FA9C</span><br><span class="line">&amp;p:<span class="number">00F</span>8FA90</span><br></pre></td></tr></table></figure><p>显然，bp完全相同。ap只是指向相同，ap俩指针本身地址不同。指针传递本质上也是值传递，只是由于传的是指向地址，所以局部更改能返回到全局</p><p>创建二叉树：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>* <span class="title">l</span>, * <span class="title">r</span>;</span></span><br><span class="line">&#125;BiNode, * BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Create</span><span class="params">(BiTree &amp;t)</span><span class="comment">//先序创建二叉树</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c = getchar();</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">t = (BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiNode));</span><br><span class="line">t-&gt;data = c;</span><br><span class="line">t-&gt;l = <span class="literal">NULL</span>;</span><br><span class="line">t-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">Create(t-&gt;l);</span><br><span class="line">Create(t-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">preOrder</span><span class="params">(BiTree t)</span> <span class="comment">//中序遍历</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">preOrder(t-&gt;l);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, t-&gt;data);</span><br><span class="line">preOrder(t-&gt;r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">BiTree t;</span><br><span class="line">Create(t);</span><br><span class="line">preOrder(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="Brian-Kernighan（可以用于清除二进制数中最右侧的1）"><a href="#Brian-Kernighan（可以用于清除二进制数中最右侧的1）" class="headerlink" title="Brian Kernighan（可以用于清除二进制数中最右侧的1）"></a>Brian Kernighan（可以用于清除二进制数中最右侧的1）</h2><p>记 f(x)表示 x 和 x-1 进行与运算所得的结果（即 f(x)&#x3D;x&amp;(x-1)，那么 f(x) 恰为 x 删去（变成0）其二进制表示中最右侧的 1 的结果。</p><h2 id="求二进制最后一位"><a href="#求二进制最后一位" class="headerlink" title="求二进制最后一位"></a>求二进制最后一位</h2><p>在循环的每一步中，我们可以使用位运算 n &amp; 1 获取 n 的最低位，判断其是否为 1。在这之后，我们将 n 右移一位：n &#x3D; n &gt;&gt; 1，这样在第 ii 步时，n &amp; 1 得到的就是初始 n 的第 i 个二进制位。</p><h1 id="整数转补码："><a href="#整数转补码：" class="headerlink" title="整数转补码："></a>整数转补码：</h1><p>对于一个正整数x，如果x的类型大小是n位的二进制数，则x的补码为：2的n次方 - x</p><p>对于一个负整数x，x的补码为2的n次方＋x</p><h1 id="找重复子串"><a href="#找重复子串" class="headerlink" title="找重复子串"></a>找重复子串</h1><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p><p>示例 1:</p><p>输入: s &#x3D; “abab”<br>输出: true<br>解释: 可由子串 “ab” 重复两次构成。<br>示例 2:</p><p>输入: s &#x3D; “aba”<br>输出: false<br>示例 3:</p><p>输入: s &#x3D; “abcabcabcabc”<br>输出: true<br>解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)</p><p>解法：我们将两个 s<em>s</em> 连在一起，并移除第一个和最后一个字符。如果 s<em>s</em> 是该字符串的子串，那么 s<em>s</em> 就满足题目要求。</p><h1 id="字符串拼接效率问题"><a href="#字符串拼接效率问题" class="headerlink" title="字符串拼接效率问题"></a>字符串拼接效率问题</h1><p>引申使用str +&#x3D; “a”， str &#x3D;str+ “a” 效率差距：</p><p>str &#x3D;str+ “a”加的运算产生的是一个新的对象，再把结果返回，而str +&#x3D; “a” 涉及到的应该是对象的引用，操作之后直接返回引用，避免了产生新的对象。因此，两者的性能有一定的差距。</p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>题目只要涉及：求大于某个数的第一个元素、下一个更大元素…这种类似的字眼的，都是单调栈的题目</p><p>对于求正因子，记住i*i&lt;num这一条件</p><h1 id="最大公因数gcd"><a href="#最大公因数gcd" class="headerlink" title="最大公因数gcd"></a>最大公因数gcd</h1><p>1.__gcd在vs内没有，devcpp内有，头文件为#include<algorithm></p><p>附上实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> __gcd(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123;</span><br><span class="line"><span class="keyword">auto</span> r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (a % b != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = a % b;</span><br><span class="line">a = b;</span><br><span class="line">b = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.斐波那契数列最大公约数定理gcd(Fn, Fm) &#x3D; F(gcd(n, m))</p><h1 id="关于C-x2F-C-的四舍五入机制"><a href="#关于C-x2F-C-的四舍五入机制" class="headerlink" title="关于C&#x2F;C++的四舍五入机制"></a>关于C&#x2F;C++的四舍五入机制</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%0.1f\n&quot;</span>, <span class="number">0.55</span>); <span class="comment">//结果：0.6  保留小数位会四舍五入</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%0.1f\n&quot;</span>, <span class="number">0.54</span>); <span class="comment">//结果：0.5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">5</span> / <span class="number">2</span>);   <span class="comment">//结果：2    直接除则不会</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与程序设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西南交大840 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/10/26/hello-world/"/>
      <url>/2022/10/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
